[
  {
    "__docId__": 0,
    "kind": "file",
    "name": "src/BotServerFacade.js",
    "content": "import { BotServer } from './BotServer';\nlet botServer;\n/**\n * Bot server may be a member of severals groups. Each group is isolated.\n * He can be invited by a group member via {@link WebGroup#invite} method.\n * @example\n * // In NodeJS:\n * // Create a bot server with full mesh topology, without autorejoin feature\n * // and with specified Signaling and ICE servers for WebRTC.\n * // Bot server is listening on 'ws://BOT_HOST:BOT_PORT'.\n *\n * const http = require('http')\n * const server = http.createServer()\n * const bot = new WebGroupBotServer({\n *   server,\n *   webGroupOptions: {\n *     signalingServer: 'wss://mysignaling.com',\n *     rtcConfiguration: {\n *       iceServers: [\n *         {\n *           urls: 'stun.l.google.com:19302'\n *         },\n *         {\n *           urls: ['turn:myturn.com?transport=udp', 'turn:myturn?transport=tcp'],\n *           username: 'user',\n *           password: 'password'\n *         }\n *       ]\n *     }\n *   }\n * })\n *\n * bot.onWebGroup = (wg) => {\n *   // YOUR CODE\n * }\n *\n * bot.onError = (err) => {\n *   // YOUR CODE\n * }\n *\n * server.listen(BOT_PORT, BOT_HOST)\n */\nexport class WebGroupBotServer {\n    /**\n     * @param {WebGroupBotServerOptions} options\n     * @param {NodeJSHttpServer|NodeJSHttpsServer} options.server NodeJS http(s) server.\n     * @param {string} [options.url] Bot server URL.\n     * @param {boolean} [options.perMessageDeflate=false] Enable/disable permessage-deflate.\n     * @param {WebGroupOptions} options.webGroupOptions Options for each {@link WebGroup} the bot is member of.\n     * @param {Topology} [options.webGroupOptions.topology=Topology.FULL_MESH]\n     * @param {string} [options.webGroupOptions.signalingServer='wss://signaling.netflux.coedit.re']\n     * @param {RTCConfiguration} [options.webGroupOptions.rtcConfiguration={iceServers: [{urls: 'stun:stun3.l.google.com:19302'}]}]\n     * @param {boolean} [options.webGroupOptions.autoRejoin=false]\n     */\n    constructor(options) {\n        botServer = new BotServer(options);\n        /**\n         * Read-only NodeJS http server instance.\n         * @type {NodeJSHttpServer|NodeJSHttpsServer}\n         */\n        this.server = undefined;\n        Reflect.defineProperty(this, 'server', { configurable: false, enumerable: true, get: () => botServer.server });\n        /**\n         * Read-only property of WebSocket server: permessage-deflate.\n         * @type {NodeJSHttpServer|NodeJSHttpsServer}\n         */\n        this.perMessageDeflate = undefined;\n        Reflect.defineProperty(this, 'perMessageDeflate', {\n            configurable: false,\n            enumerable: true,\n            get: () => botServer.perMessageDeflate,\n        });\n        /**\n         * Read-only set of web groups the bot is member of.\n         * @type {Set<WebGroup>}\n         */\n        this.webGroups = undefined;\n        Reflect.defineProperty(this, 'webGroups', { configurable: false, enumerable: true, get: () => botServer.webGroups });\n        /**\n         * Bot server url. Used to invite the bot in a web group via {@link WebGroup#invite} method.\n         * @type {string}\n         */\n        this.url = undefined;\n        Reflect.defineProperty(this, 'url', { configurable: false, enumerable: true, get: () => botServer.url });\n        /**\n         * This handler is called when the bot has been invited into a group by one of its members.\n         * @type  {function(wg: WebGroup)} handler\n         */\n        this.onWebGroup = undefined;\n        Reflect.defineProperty(this, 'onWebGroup', {\n            configurable: true,\n            enumerable: true,\n            get: () => (botServer.onWebGroup.name === 'none') ? undefined : botServer.onWebGroup,\n            set: (handler) => {\n                if (typeof handler !== 'function') {\n                    botServer.onWebGroup = function none() { };\n                }\n                else {\n                    botServer.onWebGroup = handler;\n                }\n            },\n        });\n        /**\n         * This handler is called when an error occurs on WebSocket server.\n         * @type  {function(err: Error)}\n         */\n        this.onError = undefined;\n        Reflect.defineProperty(this, 'onError', {\n            configurable: true,\n            enumerable: true,\n            get: () => (botServer.onError.name === 'none') ? undefined : botServer.onError,\n            set: (handler) => {\n                if (typeof handler !== 'function') {\n                    botServer.onError = function none() { };\n                }\n                else {\n                    botServer.onError = handler;\n                }\n            },\n        });\n    }\n}\n",
    "static": true,
    "longname": "/home/philippe/workspace/netflux/docs/jsFromTs/src/BotServerFacade.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1,
    "kind": "class",
    "name": "WebGroupBotServer",
    "memberof": "src/BotServerFacade.js",
    "static": true,
    "longname": "src/BotServerFacade.js~WebGroupBotServer",
    "access": "public",
    "export": true,
    "importPath": "netflux/src/BotServerFacade.js",
    "importStyle": "{WebGroupBotServer}",
    "description": "Bot server may be a member of severals groups. Each group is isolated.\nHe can be invited by a group member via {@link WebGroup#invite} method.",
    "examples": [
      "// In NodeJS:\n// Create a bot server with full mesh topology, without autorejoin feature\n// and with specified Signaling and ICE servers for WebRTC.\n// Bot server is listening on 'ws://BOT_HOST:BOT_PORT'.\n\nconst http = require('http')\nconst server = http.createServer()\nconst bot = new WebGroupBotServer({\n  server,\n  webGroupOptions: {\n    signalingServer: 'wss://mysignaling.com',\n    rtcConfiguration: {\n      iceServers: [\n        {\n          urls: 'stun.l.google.com:19302'\n        },\n        {\n          urls: ['turn:myturn.com?transport=udp', 'turn:myturn?transport=tcp'],\n          username: 'user',\n          password: 'password'\n        }\n      ]\n    }\n  }\n})\n\nbot.onWebGroup = (wg) => {\n  // YOUR CODE\n}\n\nbot.onError = (err) => {\n  // YOUR CODE\n}\n\nserver.listen(BOT_PORT, BOT_HOST)"
    ],
    "lineNumber": 43,
    "interface": false
  },
  {
    "__docId__": 2,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/BotServerFacade.js~WebGroupBotServer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/BotServerFacade.js~WebGroupBotServer#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 55,
    "params": [
      {
        "nullable": null,
        "types": [
          "WebGroupBotServerOptions"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "NodeJSHttpServer",
          "NodeJSHttpsServer"
        ],
        "spread": false,
        "optional": false,
        "name": "options.server",
        "description": "NodeJS http(s) server."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "options.url",
        "description": "Bot server URL."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.perMessageDeflate",
        "description": "Enable/disable permessage-deflate."
      },
      {
        "nullable": null,
        "types": [
          "WebGroupOptions"
        ],
        "spread": false,
        "optional": false,
        "name": "options.webGroupOptions",
        "description": "Options for each {@link WebGroup} the bot is member of."
      },
      {
        "nullable": null,
        "types": [
          "Topology"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "Topology.FULL_MESH",
        "defaultRaw": "Topology.FULL_MESH",
        "name": "options.webGroupOptions.topology",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'wss://signaling.netflux.coedit.re'",
        "defaultRaw": "'wss://signaling.netflux.coedit.re'",
        "name": "options.webGroupOptions.signalingServer",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "RTCConfiguration"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{iceServers: [{urls: 'stun:stun3.l.google.com:19302'}]}",
        "defaultRaw": "{iceServers: [{urls: 'stun:stun3.l.google.com:19302'}]}",
        "name": "options.webGroupOptions.rtcConfiguration",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "options.webGroupOptions.autoRejoin",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 3,
    "kind": "member",
    "name": "server",
    "memberof": "src/BotServerFacade.js~WebGroupBotServer",
    "static": false,
    "longname": "src/BotServerFacade.js~WebGroupBotServer#server",
    "access": "public",
    "description": "Read-only NodeJS http server instance.",
    "lineNumber": 61,
    "type": {
      "nullable": null,
      "types": [
        "NodeJSHttpServer",
        "NodeJSHttpsServer"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 4,
    "kind": "member",
    "name": "perMessageDeflate",
    "memberof": "src/BotServerFacade.js~WebGroupBotServer",
    "static": false,
    "longname": "src/BotServerFacade.js~WebGroupBotServer#perMessageDeflate",
    "access": "public",
    "description": "Read-only property of WebSocket server: permessage-deflate.",
    "lineNumber": 67,
    "type": {
      "nullable": null,
      "types": [
        "NodeJSHttpServer",
        "NodeJSHttpsServer"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 5,
    "kind": "member",
    "name": "webGroups",
    "memberof": "src/BotServerFacade.js~WebGroupBotServer",
    "static": false,
    "longname": "src/BotServerFacade.js~WebGroupBotServer#webGroups",
    "access": "public",
    "description": "Read-only set of web groups the bot is member of.",
    "lineNumber": 77,
    "type": {
      "nullable": null,
      "types": [
        "Set<WebGroup>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 6,
    "kind": "member",
    "name": "url",
    "memberof": "src/BotServerFacade.js~WebGroupBotServer",
    "static": false,
    "longname": "src/BotServerFacade.js~WebGroupBotServer#url",
    "access": "public",
    "description": "Bot server url. Used to invite the bot in a web group via {@link WebGroup#invite} method.",
    "lineNumber": 83,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 7,
    "kind": "member",
    "name": "onWebGroup",
    "memberof": "src/BotServerFacade.js~WebGroupBotServer",
    "static": false,
    "longname": "src/BotServerFacade.js~WebGroupBotServer#onWebGroup",
    "access": "public",
    "description": "This handler is called when the bot has been invited into a group by one of its members.",
    "lineNumber": 89,
    "type": {
      "nullable": null,
      "types": [
        "function(wg: WebGroup)"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 8,
    "kind": "member",
    "name": "onError",
    "memberof": "src/BotServerFacade.js~WebGroupBotServer",
    "static": false,
    "longname": "src/BotServerFacade.js~WebGroupBotServer#onError",
    "access": "public",
    "description": "This handler is called when an error occurs on WebSocket server.",
    "lineNumber": 107,
    "type": {
      "nullable": null,
      "types": [
        "function(err: Error)"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 9,
    "kind": "file",
    "name": "src/WebChannelFacade.js",
    "content": "import { WebChannel, WebChannelState } from './service/WebChannel';\n/**\n * Is a helper type representing types that can be sent/received over a web group.\n * @typedef {string|Uint8Array} DataType\n */\n/**\n * @ignore\n */\nexport const wcs = new WeakMap();\n/**\n * {@link WebGroup} state enum.\n */\nexport class WebGroupState {\n    /**\n     * Equals to `0`: joining the group...\n     * @type {number}\n     */\n    static get JOINING() { return WebChannelState.JOINING; }\n    /**\n     * Equals to `'JOINING'`.\n     * @type {string}\n     */\n    static get [WebGroupState.JOINING]() { return WebChannelState[WebChannelState.JOINING]; }\n    /**\n     * Equals to `1`: joined the group successfully.\n     * @type {number}\n     */\n    static get JOINED() { return WebChannelState.JOINED; }\n    /**\n     * Equals to `'JOINED'`.\n     * @type {string}\n     */\n    static get [WebGroupState.JOINED]() { return WebChannelState[WebChannelState.JOINED]; }\n    /**\n     * Equals to `2`: The `WebGroup` is in process of leaving.\n     * @type {number}\n     */\n    static get LEAVING() { return WebChannelState.LEAVING; }\n    /**\n     * Equals to `'LEAVING'`.\n     * @type {string}\n     */\n    static get [WebGroupState.LEAVING]() { return WebChannelState[WebChannelState.LEAVING]; }\n    /**\n     * Equals to `3`: left the group. If the connection to the web group has lost other then\n     * by calling {@link WebGroup#leave} methods and {@link WebGroup#autoRejoin} is true,\n     * then the state would be `LEFT`, usually during a relatively short period) before\n     * the rejoining process starts.\n     * @type {number}\n     */\n    static get LEFT() { return WebChannelState.LEFT; }\n    /**\n     * Equals to `'LEFT'`.\n     * @type {string}\n     */\n    static get [WebGroupState.LEFT]() { return WebChannelState[WebChannelState.LEFT]; }\n}\n/**\n * This class is an API starting point. It represents a peer to peer network,\n * simply called a group. Each group member can send/receive broadcast\n * as well as personal messages, invite other persons or bots (see {@link WebGroupBotServer}).\n * @example\n * // Create a WebGroup with full mesh topology, autorejoin feature and\n * // specified Signaling and ICE servers for WebRTC.\n *\n * const wg = new WebGroup({\n *   signalingServer: 'wss://mysignaling.com',\n *   rtcConfiguration: {\n *     iceServers: [\n *       {\n *         urls: 'stun.l.google.com:19302'\n *       },\n *       {\n *         urls: ['turn:myturn.com?transport=udp', 'turn:myturn?transport=tcp'],\n *         username: 'user',\n *         password: 'password'\n *       }\n *     ]\n *   }\n * })\n *\n * wg.onMemberJoin = (id) => {\n *   // YOUR CODE...\n * }\n * wg.onMemberLeave = (id) => {\n *   // YOUR CODE...\n * }\n * wg.onMessage = (id, data) => {\n *   // YOUR CODE...\n * }\n * wg.onStateChange = (state) => {\n *   // YOUR CODE...\n * }\n * wg.onSignalingStateChange = (state) => {\n *   // YOUR CODE...\n * }\n */\nexport class WebGroup {\n    /**\n     * @param {WebGroupOptions} [options]\n     * @param {Topology} [options.topology=Topology.FULL_MESH]\n     * @param {string} [options.signalingServer='wss://signaling.netflux.coedit.re']\n     * @param {RTCConfiguration} [options.rtcConfiguration={iceServers: [{urls: 'stun:stun3.l.google.com:19302'}]}]\n     * @param {boolean} [options.autoRejoin=true]\n     */\n    constructor(options = {}) {\n        const wc = new WebChannel(options);\n        wcs.set(this, wc);\n        /**\n         * The read-only {@link WebGroup} identifier. The same value for all members.\n         * @type {number}\n         */\n        this.id = undefined;\n        Reflect.defineProperty(this, 'id', { configurable: false, enumerable: true, get: () => wc.id });\n        /**\n         * The read-only your unique member identifier in the group.\n         * @type {number}\n         */\n        this.myId = undefined;\n        Reflect.defineProperty(this, 'myId', { configurable: false, enumerable: true, get: () => wc.myId });\n        /**\n         * The read-only group session identifier. Equals to an empty string before calling {@link WebGroup#join}.\n         * Different to {@link WebGroup#id}. This key is known and used by Signaling server\n         * in order to join new members, on the other hand Signaling does not know {@link WebGroup#id}.\n         * @type {string}\n         */\n        this.key = undefined;\n        Reflect.defineProperty(this, 'key', { configurable: false, enumerable: true, get: () => wc.key });\n        /**\n         * The read-only array of all members including yourself (i.e. {@link WebGroup#myId})\n         * @type {number[]}\n         */\n        this.members = undefined;\n        Reflect.defineProperty(this, 'members', { configurable: false, enumerable: true, get: () => wc.members });\n        /**\n         * The read-only property which is an enum of type {@link Topology}\n         * indicating the topology used for this {@link WebGroup} instance.\n         * @type {Topology}\n         */\n        this.topology = undefined;\n        Reflect.defineProperty(this, 'topology', { configurable: false, enumerable: true, get: () => wc.topology });\n        /**\n         * The read-only state of the {@link WebGroup} connection.\n         * @type {WebGroupState}\n         */\n        this.state = undefined;\n        Reflect.defineProperty(this, 'state', { configurable: false, enumerable: true, get: () => wc.state });\n        /**\n         * The read-only state of the signaling server.\n         * @type {SignalingState}\n         */\n        this.signalingState = undefined;\n        Reflect.defineProperty(this, 'signalingState', {\n            configurable: false,\n            enumerable: true,\n            get: () => wc.signaling.state,\n        });\n        /**\n         * The read-only signaling server URL.\n         * @type {string}\n         */\n        this.signalingServer = undefined;\n        Reflect.defineProperty(this, 'signalingServer', {\n            configurable: false,\n            enumerable: true, get: () => wc.signaling.url,\n        });\n        /**\n         * Enable/Desable the auto rejoin feature.\n         * @type {boolean}\n         */\n        this.autoRejoin = undefined;\n        Reflect.defineProperty(this, 'autoRejoin', {\n            configurable: false,\n            enumerable: true,\n            get: () => wc.autoRejoin,\n            set: (value) => wc.autoRejoin = value,\n        });\n        /**\n         * This handler is called when a message has been received from the group.\n         * `id` is an identifier of the member who sent this message.\n         * and false if sent via {@link WebGroup#sendTo}.\n         * @type {function(id: number, data: DataType)}\n         */\n        this.onMessage = undefined;\n        Reflect.defineProperty(this, 'onMessage', {\n            configurable: true,\n            enumerable: true,\n            get: () => (wc.onMessage.name === 'none') ? undefined : wc.onMessage,\n            set: (handler) => {\n                if (typeof handler !== 'function') {\n                    wc.onMessage = function none() { };\n                }\n                else {\n                    wc.onMessage = handler;\n                }\n            },\n        });\n        /**\n         * This handler is called when a new member with `id` as identifier has joined the group.\n         * @type {function(id: number)}\n         */\n        this.onMemberJoin = undefined;\n        Reflect.defineProperty(this, 'onMemberJoin', {\n            configurable: true,\n            enumerable: true,\n            get: () => (wc.onMemberJoin.name === 'none') ? undefined : wc.onMemberJoin,\n            set: (handler) => {\n                if (typeof handler !== 'function') {\n                    wc.onMemberJoin = function none() { };\n                }\n                else {\n                    wc.onMemberJoin = handler;\n                }\n            },\n        });\n        /**\n         * This handler is called when a member with `id` as identifier hes left the group.\n         * @type {function(id: number)}\n         */\n        this.onMemberLeave = undefined;\n        Reflect.defineProperty(this, 'onMemberLeave', {\n            configurable: true,\n            enumerable: true,\n            get: () => (wc.onMemberLeave.name === 'none') ? undefined : wc.onMemberLeave,\n            set: (handler) => {\n                if (typeof handler !== 'function') {\n                    wc.onMemberLeave = function none() { };\n                }\n                else {\n                    wc.onMemberLeave = handler;\n                }\n            },\n        });\n        /**\n         * This handler is called when the group state has changed.\n         * @type {function(state: WebGroupState)}\n         */\n        this.onStateChange = undefined;\n        Reflect.defineProperty(this, 'onStateChange', {\n            configurable: true,\n            enumerable: true,\n            get: () => (wc.onStateChange.name === 'none') ? undefined : wc.onStateChange,\n            set: (handler) => {\n                if (typeof handler !== 'function') {\n                    wc.onStateChange = function none() { };\n                }\n                else {\n                    wc.onStateChange = handler;\n                }\n            },\n        });\n        /**\n         * This handler is called when the signaling state has changed.\n         * @type {function(state: SignalingState)}\n         */\n        this.onSignalingStateChange = undefined;\n        Reflect.defineProperty(this, 'onSignalingStateChange', {\n            configurable: true,\n            enumerable: true,\n            get: () => (wc.onSignalingStateChange.name === 'none') ? undefined : wc.onSignalingStateChange,\n            set: (handler) => {\n                if (typeof handler !== 'function') {\n                    wc.onSignalingStateChange = function none() { };\n                }\n                else {\n                    wc.onSignalingStateChange = handler;\n                }\n            },\n        });\n    }\n    /**\n     * Join the group identified by a key provided by one of the group member.\n     * If the current {@link WebGroup#state} value is not {@link WebGroupState#LEFT} or\n     * {@link WebGroup#signalingState} value is not {@link SignalingState.CLOSED},\n     * then do nothing.\n     * @param {string} [key] Will be generated if not provided\n     */\n    join(key) {\n        const wc = wcs.get(this);\n        if (wc) {\n            return wc.join(key);\n        }\n        throw new Error('WebChannel is undefined');\n    }\n    /**\n     * Invite a bot server to join this group.\n     * @param {string} url - Bot server URL (See {@link WebGroupBotServerOptions})\n     */\n    invite(url) {\n        const wc = wcs.get(this);\n        if (wc) {\n            return wc.invite(url);\n        }\n        throw new Error('WebChannel is undefined');\n    }\n    /**\n     * Leave the group which means close channels with all members and connection\n     * with the Signaling server.\n     */\n    leave() {\n        const wc = wcs.get(this);\n        if (wc) {\n            return wc.leave();\n        }\n        throw new Error('WebChannel is undefined');\n    }\n    /**\n     * Broadcast a message to the group.\n     * @param {DataType} data\n     */\n    send(data) {\n        const wc = wcs.get(this);\n        if (wc) {\n            return wc.send(data);\n        }\n        throw new Error('WebChannel is undefined');\n    }\n    /**\n     * Send a message to a particular group member.\n     * @param {number}    id Member identifier\n     * @param {DataType}  data Message\n     */\n    sendTo(id, data) {\n        const wc = wcs.get(this);\n        if (wc) {\n            return wc.sendTo(id, data);\n        }\n        throw new Error('WebChannel is undefined');\n    }\n}\n",
    "static": true,
    "longname": "/home/philippe/workspace/netflux/docs/jsFromTs/src/WebChannelFacade.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 10,
    "kind": "typedef",
    "name": "DataType",
    "memberof": "src/WebChannelFacade.js",
    "static": true,
    "longname": "src/WebChannelFacade.js~DataType",
    "access": "public",
    "description": "Is a helper type representing types that can be sent/received over a web group.",
    "type": {
      "types": [
        "string",
        "Uint8Array"
      ],
      "optional": false,
      "name": "DataType"
    }
  },
  {
    "__docId__": 11,
    "kind": "variable",
    "name": "wcs",
    "memberof": "src/WebChannelFacade.js",
    "static": true,
    "longname": "src/WebChannelFacade.js~wcs",
    "access": "public",
    "export": true,
    "importPath": "netflux/src/WebChannelFacade.js",
    "importStyle": "{wcs}",
    "description": "",
    "lineNumber": 9,
    "ignore": true
  },
  {
    "__docId__": 12,
    "kind": "class",
    "name": "WebGroupState",
    "memberof": "src/WebChannelFacade.js",
    "static": true,
    "longname": "src/WebChannelFacade.js~WebGroupState",
    "access": "public",
    "export": true,
    "importPath": "netflux/src/WebChannelFacade.js",
    "importStyle": "{WebGroupState}",
    "description": "{@link WebGroup} state enum.",
    "lineNumber": 13,
    "interface": false
  },
  {
    "__docId__": 13,
    "kind": "get",
    "name": "JOINING",
    "memberof": "src/WebChannelFacade.js~WebGroupState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/WebChannelFacade.js~WebGroupState.JOINING",
    "access": "public",
    "description": "Equals to `0`: joining the group...",
    "lineNumber": 18,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 14,
    "kind": "get",
    "name": "[WebGroupState.JOINING]",
    "memberof": "src/WebChannelFacade.js~WebGroupState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/WebChannelFacade.js~WebGroupState.[WebGroupState.JOINING]",
    "access": "public",
    "description": "Equals to `'JOINING'`.",
    "lineNumber": 23,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 15,
    "kind": "get",
    "name": "JOINED",
    "memberof": "src/WebChannelFacade.js~WebGroupState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/WebChannelFacade.js~WebGroupState.JOINED",
    "access": "public",
    "description": "Equals to `1`: joined the group successfully.",
    "lineNumber": 28,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 16,
    "kind": "get",
    "name": "[WebGroupState.JOINED]",
    "memberof": "src/WebChannelFacade.js~WebGroupState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/WebChannelFacade.js~WebGroupState.[WebGroupState.JOINED]",
    "access": "public",
    "description": "Equals to `'JOINED'`.",
    "lineNumber": 33,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 17,
    "kind": "get",
    "name": "LEAVING",
    "memberof": "src/WebChannelFacade.js~WebGroupState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/WebChannelFacade.js~WebGroupState.LEAVING",
    "access": "public",
    "description": "Equals to `2`: The `WebGroup` is in process of leaving.",
    "lineNumber": 38,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 18,
    "kind": "get",
    "name": "[WebGroupState.LEAVING]",
    "memberof": "src/WebChannelFacade.js~WebGroupState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/WebChannelFacade.js~WebGroupState.[WebGroupState.LEAVING]",
    "access": "public",
    "description": "Equals to `'LEAVING'`.",
    "lineNumber": 43,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 19,
    "kind": "get",
    "name": "LEFT",
    "memberof": "src/WebChannelFacade.js~WebGroupState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/WebChannelFacade.js~WebGroupState.LEFT",
    "access": "public",
    "description": "Equals to `3`: left the group. If the connection to the web group has lost other then\nby calling {@link WebGroup#leave} methods and {@link WebGroup#autoRejoin} is true,\nthen the state would be `LEFT`, usually during a relatively short period) before\nthe rejoining process starts.",
    "lineNumber": 51,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 20,
    "kind": "get",
    "name": "[WebGroupState.LEFT]",
    "memberof": "src/WebChannelFacade.js~WebGroupState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/WebChannelFacade.js~WebGroupState.[WebGroupState.LEFT]",
    "access": "public",
    "description": "Equals to `'LEFT'`.",
    "lineNumber": 56,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 21,
    "kind": "class",
    "name": "WebGroup",
    "memberof": "src/WebChannelFacade.js",
    "static": true,
    "longname": "src/WebChannelFacade.js~WebGroup",
    "access": "public",
    "export": true,
    "importPath": "netflux/src/WebChannelFacade.js",
    "importStyle": "{WebGroup}",
    "description": "This class is an API starting point. It represents a peer to peer network,\nsimply called a group. Each group member can send/receive broadcast\nas well as personal messages, invite other persons or bots (see {@link WebGroupBotServer}).",
    "examples": [
      "// Create a WebGroup with full mesh topology, autorejoin feature and\n// specified Signaling and ICE servers for WebRTC.\n\nconst wg = new WebGroup({\n  signalingServer: 'wss://mysignaling.com',\n  rtcConfiguration: {\n    iceServers: [\n      {\n        urls: 'stun.l.google.com:19302'\n      },\n      {\n        urls: ['turn:myturn.com?transport=udp', 'turn:myturn?transport=tcp'],\n        username: 'user',\n        password: 'password'\n      }\n    ]\n  }\n})\n\nwg.onMemberJoin = (id) => {\n  // YOUR CODE...\n}\nwg.onMemberLeave = (id) => {\n  // YOUR CODE...\n}\nwg.onMessage = (id, data) => {\n  // YOUR CODE...\n}\nwg.onStateChange = (state) => {\n  // YOUR CODE...\n}\nwg.onSignalingStateChange = (state) => {\n  // YOUR CODE...\n}"
    ],
    "lineNumber": 98,
    "interface": false
  },
  {
    "__docId__": 22,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 106,
    "params": [
      {
        "nullable": null,
        "types": [
          "WebGroupOptions"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Topology"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "Topology.FULL_MESH",
        "defaultRaw": "Topology.FULL_MESH",
        "name": "options.topology",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "'wss://signaling.netflux.coedit.re'",
        "defaultRaw": "'wss://signaling.netflux.coedit.re'",
        "name": "options.signalingServer",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "RTCConfiguration"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{iceServers: [{urls: 'stun:stun3.l.google.com:19302'}]}",
        "defaultRaw": "{iceServers: [{urls: 'stun:stun3.l.google.com:19302'}]}",
        "name": "options.rtcConfiguration",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.autoRejoin",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 23,
    "kind": "member",
    "name": "id",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#id",
    "access": "public",
    "description": "The read-only {@link WebGroup} identifier. The same value for all members.",
    "lineNumber": 113,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 24,
    "kind": "member",
    "name": "myId",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#myId",
    "access": "public",
    "description": "The read-only your unique member identifier in the group.",
    "lineNumber": 119,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 25,
    "kind": "member",
    "name": "key",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#key",
    "access": "public",
    "description": "The read-only group session identifier. Equals to an empty string before calling {@link WebGroup#join}.\nDifferent to {@link WebGroup#id}. This key is known and used by Signaling server\nin order to join new members, on the other hand Signaling does not know {@link WebGroup#id}.",
    "lineNumber": 127,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 26,
    "kind": "member",
    "name": "members",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#members",
    "access": "public",
    "description": "The read-only array of all members including yourself (i.e. {@link WebGroup#myId})",
    "lineNumber": 133,
    "type": {
      "nullable": null,
      "types": [
        "number[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 27,
    "kind": "member",
    "name": "topology",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#topology",
    "access": "public",
    "description": "The read-only property which is an enum of type {@link Topology}\nindicating the topology used for this {@link WebGroup} instance.",
    "lineNumber": 140,
    "type": {
      "nullable": null,
      "types": [
        "Topology"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 28,
    "kind": "member",
    "name": "state",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#state",
    "access": "public",
    "description": "The read-only state of the {@link WebGroup} connection.",
    "lineNumber": 146,
    "type": {
      "nullable": null,
      "types": [
        "WebGroupState"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 29,
    "kind": "member",
    "name": "signalingState",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#signalingState",
    "access": "public",
    "description": "The read-only state of the signaling server.",
    "lineNumber": 152,
    "type": {
      "nullable": null,
      "types": [
        "SignalingState"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 30,
    "kind": "member",
    "name": "signalingServer",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#signalingServer",
    "access": "public",
    "description": "The read-only signaling server URL.",
    "lineNumber": 162,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 31,
    "kind": "member",
    "name": "autoRejoin",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#autoRejoin",
    "access": "public",
    "description": "Enable/Desable the auto rejoin feature.",
    "lineNumber": 171,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 32,
    "kind": "member",
    "name": "onMessage",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#onMessage",
    "access": "public",
    "description": "This handler is called when a message has been received from the group.\n`id` is an identifier of the member who sent this message.\nand false if sent via {@link WebGroup#sendTo}.",
    "lineNumber": 184,
    "type": {
      "nullable": null,
      "types": [
        "function(id: number, data: DataType)"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 33,
    "kind": "member",
    "name": "onMemberJoin",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#onMemberJoin",
    "access": "public",
    "description": "This handler is called when a new member with `id` as identifier has joined the group.",
    "lineNumber": 202,
    "type": {
      "nullable": null,
      "types": [
        "function(id: number)"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 34,
    "kind": "member",
    "name": "onMemberLeave",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#onMemberLeave",
    "access": "public",
    "description": "This handler is called when a member with `id` as identifier hes left the group.",
    "lineNumber": 220,
    "type": {
      "nullable": null,
      "types": [
        "function(id: number)"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 35,
    "kind": "member",
    "name": "onStateChange",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#onStateChange",
    "access": "public",
    "description": "This handler is called when the group state has changed.",
    "lineNumber": 238,
    "type": {
      "nullable": null,
      "types": [
        "function(state: WebGroupState)"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 36,
    "kind": "member",
    "name": "onSignalingStateChange",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#onSignalingStateChange",
    "access": "public",
    "description": "This handler is called when the signaling state has changed.",
    "lineNumber": 256,
    "type": {
      "nullable": null,
      "types": [
        "function(state: SignalingState)"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 37,
    "kind": "method",
    "name": "join",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#join",
    "access": "public",
    "description": "Join the group identified by a key provided by one of the group member.\nIf the current {@link WebGroup#state} value is not {@link WebGroupState#LEFT} or\n{@link WebGroup#signalingState} value is not {@link SignalingState.CLOSED},\nthen do nothing.",
    "lineNumber": 278,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "key",
        "description": "Will be generated if not provided"
      }
    ]
  },
  {
    "__docId__": 38,
    "kind": "method",
    "name": "invite",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#invite",
    "access": "public",
    "description": "Invite a bot server to join this group.",
    "lineNumber": 289,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "Bot server URL (See {@link WebGroupBotServerOptions})"
      }
    ]
  },
  {
    "__docId__": 39,
    "kind": "method",
    "name": "leave",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#leave",
    "access": "public",
    "description": "Leave the group which means close channels with all members and connection\nwith the Signaling server.",
    "lineNumber": 300
  },
  {
    "__docId__": 40,
    "kind": "method",
    "name": "send",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#send",
    "access": "public",
    "description": "Broadcast a message to the group.",
    "lineNumber": 311,
    "params": [
      {
        "nullable": null,
        "types": [
          "DataType"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 41,
    "kind": "method",
    "name": "sendTo",
    "memberof": "src/WebChannelFacade.js~WebGroup",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebChannelFacade.js~WebGroup#sendTo",
    "access": "public",
    "description": "Send a message to a particular group member.",
    "lineNumber": 323,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "Member identifier"
      },
      {
        "nullable": null,
        "types": [
          "DataType"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "Message"
      }
    ]
  },
  {
    "__docId__": 42,
    "kind": "file",
    "name": "src/index.common.js",
    "content": "import { LogLevel as Logs, setLogLevel as setLogs } from './misc/Util';\nimport { TopologyEnum } from './service/topology/Topology';\nimport { SignalingState as SigState } from './Signaling';\nexport { WebGroup, WebGroupState } from './WebChannelFacade';\n/**\n * Set log level for debugging utility. By default all logs are disabled.\n * @param {...LogLevel} levels\n */\nexport function setLogLevel(...levels) { setLogs(levels); }\n/**\n * The state enum of the signaling server for WebRTC.\n */\nexport class SignalingState {\n    /**\n     * Equals to `0`, the connection is not yet open. Value\n     * @type {number}\n     */\n    static get CONNECTING() { return SigState.CONNECTING; }\n    /**\n     * Equals to `'CONNECTING'`.\n     * @type {string}\n     */\n    static get [SignalingState.CONNECTING]() { return SigState[SigState.CONNECTING]; }\n    /**\n     * Equals to `1`, `RTCDataChannel` has been established with one of the group member.\n     * From now the signaling is no longer needed, because the joining process\n     * will continue with a help of this member.\n     * @type {number}\n     */\n    static get CONNECTED() { return SigState.CONNECTED; }\n    /**\n     * Equals to `'CONNECTED'`.\n     * @type {string}\n     */\n    static get [SignalingState.CONNECTED]() {\n        return SigState[SigState.CONNECTED];\n    }\n    /**\n     * Equals to `2`, you has successfully joined a web group and ready to help join others.\n     * @type {number}\n     */\n    static get STABLE() { return SigState.STABLE; }\n    /**\n     * Equals to `'STABLE'`.\n     * @type {string}\n     */\n    static get [SignalingState.STABLE]() { return SigState[SigState.STABLE]; }\n    /**\n     * Equals to `3`, the connection is in process of closing.\n     * @type {number}\n     */\n    static get CLOSING() { return SigState.CLOSING; }\n    /**\n     * Equals to `'CLOSING'`.\n     * @type {string}\n     */\n    static get [SignalingState.CLOSING]() { return SigState[SigState.CLOSING]; }\n    /**\n     * Equals to `4`, the connection is closed.\n     * @type {number}\n     */\n    static get CLOSED() { return SigState.CLOSED; }\n    /**\n     * Equals to `'CLOSED'`.\n     * @type {string}\n     */\n    static get [SignalingState.CLOSED]() { return SigState[SigState.CLOSED]; }\n}\n/**\n * The topology enum.\n */\nexport class Topology {\n    /**\n     * Full mesh topology identifier.\n     * @type {number}\n     */\n    static get FULL_MESH() { return TopologyEnum.FULL_MESH; }\n    /**\n     * Equals to `'FULL_MESH'`.\n     * @type {string}\n     */\n    static get [Topology.FULL_MESH]() { return TopologyEnum[TopologyEnum.FULL_MESH]; }\n}\n/**\n * The log level enum.\n */\nexport class LogLevel {\n    /**\n     * Equals to `1`, allows logs for debug.\n     * @type {number}\n     */\n    static get DEBUG() { return Logs.DEBUG; }\n    /**\n     * Equals to `'DEBUG'`.\n     * @type {string}\n     */\n    static get [Logs.DEBUG]() { return Logs[Logs.DEBUG]; }\n    /**\n     * Equals to `2`, logs for WebGroup module.\n     * @type {number}\n     */\n    static get WEB_GROUP() { return Logs.WEB_GROUP; }\n    /**\n     * Equals to `'WEB_GROUP'`.\n     * @type {string}\n     */\n    static get [Logs.WEB_GROUP]() { return Logs[Logs.WEB_GROUP]; }\n    /**\n     * Equals to `3`, logs for WebRTCBuilder module.\n     * @type {number}\n     */\n    static get WEBRTC() { return Logs.WEBRTC; }\n    /**\n     * Equals to `'WEBRTC'`.\n     * @type {string}\n     */\n    static get [Logs.WEBRTC]() { return Logs[Logs.WEBRTC]; }\n    /**\n     * Equals to `4`, logs for Channel module.\n     * @type {number}\n     */\n    static get CHANNEL() { return Logs.CHANNEL; }\n    /**\n     * Equals to `'CHANNEL'`.\n     * @type {string}\n     */\n    static get [Logs.CHANNEL]() { return Logs[Logs.CHANNEL]; }\n    /**\n     * Equals to `5`, logs for Topology module.\n     * @type {number}\n     */\n    static get TOPOLOGY() { return Logs.TOPOLOGY; }\n    /**\n     * Equals to `'TOPOLOGY'`.\n     * @type {string}\n     */\n    static get [Logs.TOPOLOGY]() { return Logs[Logs.TOPOLOGY]; }\n    /**\n     * Equals to `6`, logs for Signaling module.\n     * @type {number}\n     */\n    static get SIGNALING() { return Logs.SIGNALING; }\n    /**\n     * Equals to `'SIGNALING'`.\n     * @type {string}\n     */\n    static get [Logs.SIGNALING]() { return Logs[Logs.SIGNALING]; }\n    /**\n     * Equals to `7`, logs for ChannelBuilder module.\n     * @type {number}\n     */\n    static get CHANNEL_BUILDER() { return Logs.CHANNEL_BUILDER; }\n    /**\n     * Equals to `'CHANNEL_BUILDER'`.\n     * @type {string}\n     */\n    static get [Logs.CHANNEL_BUILDER]() { return Logs[Logs.CHANNEL_BUILDER]; }\n}\n/**\n * The options to be passed into {@link WebGroup} constructor.\n * @typedef {Object} WebGroupOptions\n * @property {Topology} [topology] Topology identifier\n * (Full mesh is the only one supported by Netflux for now).\n * @property {string} [signalingServer] Signaling URL for WebRTC.\n * @property {RTCConfiguration} [rtcConfiguration] Configuration for WebRTC.\n * @property {boolean} [autoRejoin] Whether to automatically rejoin the web group\n * on disconnect or not. Its value may be modified after {@link WebGroup}\n * instantiation at any time.\n */\n/**\n * The options to be passed into {@link WebGroupBotServer} constructor.\n * @typedef {Object} WebGroupBotServerOptions\n * @property {Topology} [topology] See WebGroupOptions.topology\n * @property {string} [signalingServer] See WebGroupOptions.signalingServer\n * @property {RTCConfiguration} [rtcConfiguration] See WebGroupOptions.rtcConfiguration\n * @property {boolean} [autoRejoin] See WebGroupOptions.autoRejoin\n * @property {Object} bot Server related options of the bot.\n * @property {NodeJSHttpServer|NodeJSHttpsServer} bot.server NodeJS http(s) server.\n * @property {string} [bot.url] Bot server URL.\n * @property {boolean} [bot.perMessageDeflate] Enable/disable permessage-deflate.\n */\n/**\n * @external {RTCConfiguration} https://developer.mozilla.org/en/docs/Web/API/RTCConfiguration\n */\n/**\n * @external {Uint8Array} https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array\n */\n/**\n * @external {NodeJSHttpServer} https://nodejs.org/api/http.html#http_class_http_server\n */\n/**\n * @external {NodeJSHttpsServer} https://nodejs.org/api/https.html#https_class_https_server\n */\n",
    "static": true,
    "longname": "/home/philippe/workspace/netflux/docs/jsFromTs/src/index.common.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 43,
    "kind": "function",
    "name": "setLogLevel",
    "memberof": "src/index.common.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.js~setLogLevel",
    "access": "public",
    "export": true,
    "importPath": "netflux/src/index.common.js",
    "importStyle": "{setLogLevel}",
    "description": "Set log level for debugging utility. By default all logs are disabled.",
    "lineNumber": 9,
    "params": [
      {
        "nullable": null,
        "types": [
          "...LogLevel"
        ],
        "spread": true,
        "optional": false,
        "name": "levels",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 44,
    "kind": "class",
    "name": "SignalingState",
    "memberof": "src/index.common.js",
    "static": true,
    "longname": "src/index.common.js~SignalingState",
    "access": "public",
    "export": true,
    "importPath": "netflux/src/index.common.js",
    "importStyle": "{SignalingState}",
    "description": "The state enum of the signaling server for WebRTC.",
    "lineNumber": 13,
    "interface": false
  },
  {
    "__docId__": 45,
    "kind": "get",
    "name": "CONNECTING",
    "memberof": "src/index.common.js~SignalingState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.js~SignalingState.CONNECTING",
    "access": "public",
    "description": "Equals to `0`, the connection is not yet open. Value",
    "lineNumber": 18,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 46,
    "kind": "get",
    "name": "[SignalingState.CONNECTING]",
    "memberof": "src/index.common.js~SignalingState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.js~SignalingState.[SignalingState.CONNECTING]",
    "access": "public",
    "description": "Equals to `'CONNECTING'`.",
    "lineNumber": 23,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 47,
    "kind": "get",
    "name": "CONNECTED",
    "memberof": "src/index.common.js~SignalingState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.js~SignalingState.CONNECTED",
    "access": "public",
    "description": "Equals to `1`, `RTCDataChannel` has been established with one of the group member.\nFrom now the signaling is no longer needed, because the joining process\nwill continue with a help of this member.",
    "lineNumber": 30,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 48,
    "kind": "get",
    "name": "[SignalingState.CONNECTED]",
    "memberof": "src/index.common.js~SignalingState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.js~SignalingState.[SignalingState.CONNECTED]",
    "access": "public",
    "description": "Equals to `'CONNECTED'`.",
    "lineNumber": 35,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 49,
    "kind": "get",
    "name": "STABLE",
    "memberof": "src/index.common.js~SignalingState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.js~SignalingState.STABLE",
    "access": "public",
    "description": "Equals to `2`, you has successfully joined a web group and ready to help join others.",
    "lineNumber": 42,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 50,
    "kind": "get",
    "name": "[SignalingState.STABLE]",
    "memberof": "src/index.common.js~SignalingState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.js~SignalingState.[SignalingState.STABLE]",
    "access": "public",
    "description": "Equals to `'STABLE'`.",
    "lineNumber": 47,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 51,
    "kind": "get",
    "name": "CLOSING",
    "memberof": "src/index.common.js~SignalingState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.js~SignalingState.CLOSING",
    "access": "public",
    "description": "Equals to `3`, the connection is in process of closing.",
    "lineNumber": 52,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 52,
    "kind": "get",
    "name": "[SignalingState.CLOSING]",
    "memberof": "src/index.common.js~SignalingState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.js~SignalingState.[SignalingState.CLOSING]",
    "access": "public",
    "description": "Equals to `'CLOSING'`.",
    "lineNumber": 57,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 53,
    "kind": "get",
    "name": "CLOSED",
    "memberof": "src/index.common.js~SignalingState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.js~SignalingState.CLOSED",
    "access": "public",
    "description": "Equals to `4`, the connection is closed.",
    "lineNumber": 62,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 54,
    "kind": "get",
    "name": "[SignalingState.CLOSED]",
    "memberof": "src/index.common.js~SignalingState",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.js~SignalingState.[SignalingState.CLOSED]",
    "access": "public",
    "description": "Equals to `'CLOSED'`.",
    "lineNumber": 67,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 55,
    "kind": "class",
    "name": "Topology",
    "memberof": "src/index.common.js",
    "static": true,
    "longname": "src/index.common.js~Topology",
    "access": "public",
    "export": true,
    "importPath": "netflux/src/index.common.js",
    "importStyle": "{Topology}",
    "description": "The topology enum.",
    "lineNumber": 72,
    "interface": false
  },
  {
    "__docId__": 56,
    "kind": "get",
    "name": "FULL_MESH",
    "memberof": "src/index.common.js~Topology",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.js~Topology.FULL_MESH",
    "access": "public",
    "description": "Full mesh topology identifier.",
    "lineNumber": 77,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 57,
    "kind": "get",
    "name": "[Topology.FULL_MESH]",
    "memberof": "src/index.common.js~Topology",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.js~Topology.[Topology.FULL_MESH]",
    "access": "public",
    "description": "Equals to `'FULL_MESH'`.",
    "lineNumber": 82,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 58,
    "kind": "class",
    "name": "LogLevel",
    "memberof": "src/index.common.js",
    "static": true,
    "longname": "src/index.common.js~LogLevel",
    "access": "public",
    "export": true,
    "importPath": "netflux/src/index.common.js",
    "importStyle": "{LogLevel}",
    "description": "The log level enum.",
    "lineNumber": 87,
    "interface": false
  },
  {
    "__docId__": 59,
    "kind": "typedef",
    "name": "WebGroupOptions",
    "memberof": "src/index.common.js",
    "static": true,
    "longname": "src/index.common.js~WebGroupOptions",
    "access": "public",
    "description": "The options to be passed into {@link WebGroup} constructor.",
    "properties": [
      {
        "nullable": null,
        "types": [
          "Topology"
        ],
        "spread": false,
        "optional": true,
        "name": "topology",
        "description": "Topology identifier\n(Full mesh is the only one supported by Netflux for now)."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "signalingServer",
        "description": "Signaling URL for WebRTC."
      },
      {
        "nullable": null,
        "types": [
          "RTCConfiguration"
        ],
        "spread": false,
        "optional": true,
        "name": "rtcConfiguration",
        "description": "Configuration for WebRTC."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "autoRejoin",
        "description": "Whether to automatically rejoin the web group\non disconnect or not. Its value may be modified after {@link WebGroup}\ninstantiation at any time."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "WebGroupOptions"
    }
  },
  {
    "__docId__": 60,
    "kind": "typedef",
    "name": "WebGroupBotServerOptions",
    "memberof": "src/index.common.js",
    "static": true,
    "longname": "src/index.common.js~WebGroupBotServerOptions",
    "access": "public",
    "description": "The options to be passed into {@link WebGroupBotServer} constructor.",
    "properties": [
      {
        "nullable": null,
        "types": [
          "Topology"
        ],
        "spread": false,
        "optional": true,
        "name": "topology",
        "description": "See WebGroupOptions.topology"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "signalingServer",
        "description": "See WebGroupOptions.signalingServer"
      },
      {
        "nullable": null,
        "types": [
          "RTCConfiguration"
        ],
        "spread": false,
        "optional": true,
        "name": "rtcConfiguration",
        "description": "See WebGroupOptions.rtcConfiguration"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "autoRejoin",
        "description": "See WebGroupOptions.autoRejoin"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "bot",
        "description": "Server related options of the bot."
      },
      {
        "nullable": null,
        "types": [
          "NodeJSHttpServer",
          "NodeJSHttpsServer"
        ],
        "spread": false,
        "optional": false,
        "name": "bot.server",
        "description": "NodeJS http(s) server."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "bot.url",
        "description": "Bot server URL."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "bot.perMessageDeflate",
        "description": "Enable/disable permessage-deflate."
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "WebGroupBotServerOptions"
    }
  },
  {
    "__docId__": 61,
    "kind": "external",
    "name": "RTCConfiguration",
    "externalLink": "https://developer.mozilla.org/en/docs/Web/API/RTCConfiguration",
    "memberof": "src/index.common.js",
    "static": true,
    "longname": "src/index.common.js~RTCConfiguration",
    "access": "public",
    "description": ""
  },
  {
    "__docId__": 62,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "src/index.common.js",
    "static": true,
    "longname": "src/index.common.js~Uint8Array",
    "access": "public",
    "description": ""
  },
  {
    "__docId__": 63,
    "kind": "external",
    "name": "NodeJSHttpServer",
    "externalLink": "https://nodejs.org/api/http.html#http_class_http_server",
    "memberof": "src/index.common.js",
    "static": true,
    "longname": "src/index.common.js~NodeJSHttpServer",
    "access": "public",
    "description": ""
  },
  {
    "__docId__": 64,
    "kind": "external",
    "name": "NodeJSHttpsServer",
    "externalLink": "https://nodejs.org/api/https.html#https_class_https_server",
    "memberof": "src/index.common.js",
    "static": true,
    "longname": "src/index.common.js~NodeJSHttpsServer",
    "access": "public",
    "description": ""
  },
  {
    "__docId__": 65,
    "kind": "get",
    "name": "DEBUG",
    "memberof": "src/index.common.js~LogLevel",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.js~LogLevel.DEBUG",
    "access": "public",
    "description": "Equals to `1`, allows logs for debug.",
    "lineNumber": 92,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 66,
    "kind": "get",
    "name": "[Logs.DEBUG]",
    "memberof": "src/index.common.js~LogLevel",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.js~LogLevel.[Logs.DEBUG]",
    "access": "public",
    "description": "Equals to `'DEBUG'`.",
    "lineNumber": 97,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 67,
    "kind": "get",
    "name": "WEB_GROUP",
    "memberof": "src/index.common.js~LogLevel",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.js~LogLevel.WEB_GROUP",
    "access": "public",
    "description": "Equals to `2`, logs for WebGroup module.",
    "lineNumber": 102,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 68,
    "kind": "get",
    "name": "[Logs.WEB_GROUP]",
    "memberof": "src/index.common.js~LogLevel",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.js~LogLevel.[Logs.WEB_GROUP]",
    "access": "public",
    "description": "Equals to `'WEB_GROUP'`.",
    "lineNumber": 107,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 69,
    "kind": "get",
    "name": "WEBRTC",
    "memberof": "src/index.common.js~LogLevel",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.js~LogLevel.WEBRTC",
    "access": "public",
    "description": "Equals to `3`, logs for WebRTCBuilder module.",
    "lineNumber": 112,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 70,
    "kind": "get",
    "name": "[Logs.WEBRTC]",
    "memberof": "src/index.common.js~LogLevel",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.js~LogLevel.[Logs.WEBRTC]",
    "access": "public",
    "description": "Equals to `'WEBRTC'`.",
    "lineNumber": 117,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 71,
    "kind": "get",
    "name": "CHANNEL",
    "memberof": "src/index.common.js~LogLevel",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.js~LogLevel.CHANNEL",
    "access": "public",
    "description": "Equals to `4`, logs for Channel module.",
    "lineNumber": 122,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 72,
    "kind": "get",
    "name": "[Logs.CHANNEL]",
    "memberof": "src/index.common.js~LogLevel",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.js~LogLevel.[Logs.CHANNEL]",
    "access": "public",
    "description": "Equals to `'CHANNEL'`.",
    "lineNumber": 127,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 73,
    "kind": "get",
    "name": "TOPOLOGY",
    "memberof": "src/index.common.js~LogLevel",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.js~LogLevel.TOPOLOGY",
    "access": "public",
    "description": "Equals to `5`, logs for Topology module.",
    "lineNumber": 132,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 74,
    "kind": "get",
    "name": "[Logs.TOPOLOGY]",
    "memberof": "src/index.common.js~LogLevel",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.js~LogLevel.[Logs.TOPOLOGY]",
    "access": "public",
    "description": "Equals to `'TOPOLOGY'`.",
    "lineNumber": 137,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 75,
    "kind": "get",
    "name": "SIGNALING",
    "memberof": "src/index.common.js~LogLevel",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.js~LogLevel.SIGNALING",
    "access": "public",
    "description": "Equals to `6`, logs for Signaling module.",
    "lineNumber": 142,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 76,
    "kind": "get",
    "name": "[Logs.SIGNALING]",
    "memberof": "src/index.common.js~LogLevel",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.js~LogLevel.[Logs.SIGNALING]",
    "access": "public",
    "description": "Equals to `'SIGNALING'`.",
    "lineNumber": 147,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 77,
    "kind": "get",
    "name": "CHANNEL_BUILDER",
    "memberof": "src/index.common.js~LogLevel",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.js~LogLevel.CHANNEL_BUILDER",
    "access": "public",
    "description": "Equals to `7`, logs for ChannelBuilder module.",
    "lineNumber": 152,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 78,
    "kind": "get",
    "name": "[Logs.CHANNEL_BUILDER]",
    "memberof": "src/index.common.js~LogLevel",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.common.js~LogLevel.[Logs.CHANNEL_BUILDER]",
    "access": "public",
    "description": "Equals to `'CHANNEL_BUILDER'`.",
    "lineNumber": 157,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "kind": "index",
    "content": "<p align=\"center\">\n  <a href=\"https://coast-team.github.io/netflux\">\n    <img src=\"manual/asset/logo_cropped.png\" />\n  </a>\n</p>\n\n<p align=\"center\">\n  Universal Javascript <strong style=\"font-weight: bold\">peer to peer</strong> transport API for client and server.<br />\n  Secure and fault tolerant full mesh peer to peer network based on <strong style=\"font-weight: bold\">RTCDataChannel</strong> and <strong style=\"font-weight: bold\">WebSocket</strong>.<br />\n  Send/receive <strong style=\"font-weight: bold\">String</strong> and <strong style=\"font-weight: bold\">Uint8Array</strong> data types.<br />\n  Documentation: https://coast-team.github.io/netflux\n</p>\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/netflux\">\n    <img src=\"https://img.shields.io/npm/v/netflux.svg?style=flat-square\" />\n  </a>&nbsp;\n  <a href=\"https://travis-ci.org/coast-team/netflux\">\n    <img src=\"https://travis-ci.org/coast-team/netflux.svg?branch=master\" />\n  </a>\n\n  <br />\n\n  <a href=\"https://www.bithound.io/github/coast-team/netflux\">\n    <img src=\"https://www.bithound.io/github/coast-team/netflux/badges/score.svg\" />\n  </a>&nbsp;\n  <a href=\"https://codeclimate.com/github/coast-team/netflux\">\n    <img src=\"https://codeclimate.com/github/coast-team/netflux/badges/gpa.svg\" />\n  </a>&nbsp;\n  <a href=\"https://coast-team.github.io/netflux\">\n    <img src=\"https://coast-team.github.io/netflux/badge.svg\" />\n  </a>&nbsp;\n  <a href=\"https://codeclimate.com/github/coast-team/netflux/coverage\"><img src=\"https://codeclimate.com/github/coast-team/netflux/badges/coverage.svg\" /></a>\n\n  <br />\n\n  <a href=\"http://commitizen.github.io/cz-cli\">\n    <img src=\"https://img.shields.io/badge/commitizen-friendly-brightgreen.svg?style=flat-square\" />\n  </a>&nbsp;\n  <a href=\"https://github.com/semantic-release/semantic-release\">\n    <img src=\"https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg?style=flat-square\" />\n  </a>&nbsp;\n  <a href=\"https://gitter.im/coast-team/netflux?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge\">\n    <img src=\"https://img.shields.io/badge/GITTER-join%20chat-green.svg?style=flat-square\" />\n  </a>\n</p>\n\n<p align=\"center\">\n  <img src=\"manual/asset/example.png\" />\n</p>\n\n## Features\n\n* Peer to peer full mesh network which accepts connection failures between some peers.\n* If connection between two members failed, other members will retransmit messages for them.\n* Automatic rejoin the group if connection lost.\n* Automatic selection between [WebSocket][WebSocket] & [RTCDataChannel][RTCDataChannel].\n* Possible to have mixed members: clients (Chrome, Firefox) and servers (NodeJS bot).\n* Send private or broadcast [String][String], [Uint8Array][Uint8Array] data types.\n* Possible to send big size data.\n* All connections are encrypted.\n* Full control over WebRTC servers: Signaling, STUN and TURN.\n  * Deploy your own Signaling server ([Sigver][Sigver]) or use one provided by default.\n  * Configure STUN and TURN servers.\n* Small Signaling server payload.\n* Signaling server is used only to establish connection between two peers, no user data is passing through it.\n* Universal API (works in Chrome/Firefox and NodeJS).\n* TypeScript declaration files are included.\n* Simple and familiar API usage.\n* 4 builds (ES5 code):\n  * `dist/netflux.cjs.js` * CommonJS format for NodeJS (see *package.json#main*).\n  * `dist/esm/index.node.js` * ES module format for NodeJS (see *package.json#module*).\n  * `dist/esm/index.browser.js` * ES module format for browsers (see *package.json#browser*).\n  * `dist/netflux.umd.js` * UMD format for browsers.\n\n## Usage\n\nHere is a basic usage example for client and server (checkout the [documenation](https://coast-team.github.io/netflux) for more details).\n\n> It is possible to have only clients without any bot server as his is not a mandatory member, but like any other group member.\n\n### Client\n\n```javascript\nimport { WebGroup, WebGroupState } from 'netflux'\n\n// Create instance and set callbacks\nconst wg = new WebGroup()\nwg.onMemberJoin = (id) => {\n  console.log('Member ' + id + ' has joined')\n  console.log('All members are: ', wg.members)\n}\nwg.onMemberLeave = (id) => {\n  console.log('Member ' + id + ' has left')\n  console.log('All members are: ', wg.members)\n}\nwg.onMessage = (id, data) => {\n  console.log(`Message from ${id} group member`, data)\n}\nwg.onStateChange = (state) => {\n  console.log('The new Group state is ', state)\n  switch (state) {\n    case WebGroupState.JOINING:\n      // Do something\n      break\n    case WebGroupState.JOINED:\n      // Do something\n      // For example inviting a bot...\n      wg.invite('BOT_SERVER_WEB_SOCKET_URL')\n      break\n    case WebGroupState.LEAVING:\n      // Do something\n      break\n    case WebGroupState.LEFT:\n      // Do something\n      break\n  }\n}\n\n// Join the group\nwg.join('MY_UNIQUE_KEY_FOR_THE_GROUP')\n```\n\n### Bot Server\n\n```javascript\nimport { WebGroupBotServer } from 'netflux'\nconst http = require('http') // https is also possible\nconst server = http.createServer()\n\nconst bot = new WebGroupBotServer({\n  server: server,\n  webGroupOptions: {\n    // Any WebGroup options like for a client\n  }\n})\n\nbot.onWebGroup = (wg) => {\n  // New instance of a WebGroup (Someone has invited this bot).\n  // See example above for client as it is the same API.\n}\n\nserver.listen(BOT_PORT, _BOT_HOST)\n// A client may invite this bot with the following URL: 'ws://BOT_HOST:BOT_PORT'\n```\n\n## Demo\n\nNetflux is used by our team for Multi User Text Editor ([MUTE repo](https://github.com/coast-team/mute)) development. The demo version is available on: https://coedit.re\n\n[WebSocket]: https://developer.mozilla.org/en/docs/Web/API/WebSocket\n[RTCDataChannel]: https://developer.mozilla.org/en/docs/Web/API/RTCDataChannel\n[String]: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String\n[Uint8Array]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array\n[Sigver]: https://github.com/coast-team/sigver\n\n[commitizen]: https://img.shields.io/badge/commitizen-friendly-brightgreen.svg?style=flat-square\n[commitizen-url]: http://commitizen.github.io/cz-cli\n\n[bithound]: https://www.bithound.io/github/coast-team/netflux/badges/score.svg\n[bithound-url]: https://www.bithound.io/github/coast-team/netflux\n\n[codeclimate]: https://codeclimate.com/github/coast-team/netflux/badges/gpa.svg\n[codeclimate-url]: https://codeclimate.com/github/coast-team/netflux\n\n[coverage]: https://codeclimate.com/github/coast-team/netflux/badges/coverage.svg\n[coverage-url]: https://codeclimate.com/github/coast-team/netflux/coverage\n\n[doc]: https://coast-team.github.io/netflux/badge.svg\n[doc-url]: https://coast-team.github.io/netflux/netflux\n\n[logo]: manual/asset/logo_cropped.png \"Netflux logo\"\n",
    "longname": "/home/philippe/workspace/netflux/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manualIndex",
    "globalIndex": true,
    "content": "# Netflux\n\n![Netflux logo][logo]\n\nUniversal Javascript **peer to peer** transport API for client and server.\n\nSecure and fault tolerant full mesh peer to peer network based on **RTCDataChannel** and **WebSocket**.\n\nSend/receive **String** and **Uint8Array** data types.\n\n<p align=\"center\">\n  <a href=\"https://www.npmjs.com/package/netflux\">\n    <img src=\"https://img.shields.io/npm/v/netflux.svg?style=flat-square\" />\n  </a>&nbsp;\n  <a href=\"https://travis-ci.org/coast-team/netflux\">\n    <img src=\"https://travis-ci.org/coast-team/netflux.svg?branch=master\" />\n  </a>\n\n  <br />\n\n  <a href=\"https://www.bithound.io/github/coast-team/netflux\">\n    <img src=\"https://www.bithound.io/github/coast-team/netflux/badges/score.svg\" />\n  </a>&nbsp;\n  <a href=\"https://codeclimate.com/github/coast-team/netflux\">\n    <img src=\"https://codeclimate.com/github/coast-team/netflux/badges/gpa.svg\" />\n  </a>&nbsp;\n  <a href=\"https://coast-team.github.io/netflux\">\n    <img src=\"https://coast-team.github.io/netflux/badge.svg\" />\n  </a>&nbsp;\n  <a href=\"https://codeclimate.com/github/coast-team/netflux/coverage\"><img src=\"https://codeclimate.com/github/coast-team/netflux/badges/coverage.svg\" /></a>\n\n  <br />\n\n  <a href=\"http://commitizen.github.io/cz-cli\">\n    <img src=\"https://img.shields.io/badge/commitizen-friendly-brightgreen.svg?style=flat-square\" />\n  </a>&nbsp;\n  <a href=\"https://github.com/semantic-release/semantic-release\">\n    <img src=\"https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg?style=flat-square\" />\n  </a>&nbsp;\n  <a href=\"https://gitter.im/coast-team/netflux?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge\">\n    <img src=\"https://img.shields.io/badge/GITTER-join%20chat-green.svg?style=flat-square\" />\n  </a>\n</p>\n\n<p align=\"center\">\n  <img src=\"manual/asset/example.svg?sanitize=true\" />\n</p>\n\n## Features\n\n* Peer to peer full mesh network which accepts connection failures between some peers.\n* If connection between two members failed, other members will retransmit messages for them.\n* Automatic rejoin the group if connection lost.\n* Automatic selection between [WebSocket][WebSocket] & [RTCDataChannel][RTCDataChannel].\n* Possible to have mixed members: clients (Chrome, Firefox) and servers (NodeJS bot).\n* Send private or broadcast [String][String], [Uint8Array][Uint8Array] data types.\n* Possible to send big size data.\n* All connections are encrypted.\n* Full control over WebRTC servers: Signaling, STUN and TURN.\n  * Deploy your own Signaling server ([Sigver][Sigver]) or use one provided by default.\n  * Configure STUN and TURN servers.\n* Small Signaling server payload.\n* Signaling server is used only to establish connection between two peers, no user data is passing through it.\n* Universal API (works in Chrome/Firefox and NodeJS).\n* TypeScript declaration files are included.\n* Simple and familiar API usage.\n* 4 builds (ES5 code):\n  * `dist/netflux.cjs.js` * CommonJS format for NodeJS (see *package.json#main*).\n  * `dist/esm/index.node.js` * ES module format for NodeJS (see *package.json#module*).\n  * `dist/esm/index.browser.js` * ES module format for browsers (see *package.json#browser*).\n  * `dist/netflux.umd.js` * UMD format for browsers.\n\n## Usage\n\nHere is a basic usage example for client and server (checkout the [documenation](https://coast-team.github.io/netflux) for more details).\n\n> It is possible to have only clients without any bot server as his is not a mandatory member, but like any other group member.\n\n### Client\n\n```javascript\nimport { WebGroup, WebGroupState } from 'netflux'\n\n// Create instance and set callbacks\nconst wg = new WebGroup()\nwg.onMemberJoin = (id) => {\n  console.log('Member ' + id + ' has joined')\n  console.log('All members are: ', wg.members)\n}\nwg.onMemberLeave = (id) => {\n  console.log('Member ' + id + ' has left')\n  console.log('All members are: ', wg.members)\n}\nwg.onMessage = (id, data) => {\n  console.log(`Message from ${id} group member`, data)\n}\nwg.onStateChange = (state) => {\n  console.log('The new Group state is ', state)\n  switch (state) {\n    case WebGroupState.JOINING:\n      // Do something\n      break\n    case WebGroupState.JOINED:\n      // Do something\n      // For example inviting a bot...\n      wg.invite('BOT_SERVER_WEB_SOCKET_URL')\n      break\n    case WebGroupState.LEAVING:\n      // Do something\n      break\n    case WebGroupState.LEFT:\n      // Do something\n      break\n  }\n}\n\n// Join the group\nwg.join('MY_UNIQUE_KEY_FOR_THE_GROUP')\n```\n\n### Bot Server\n\n```javascript\nimport { WebGroupBotServer } from 'netflux'\nconst http = require('http') // https is also possible\nconst server = http.createServer()\n\nconst bot = new WebGroupBotServer({\n  server: server,\n  webGroupOptions: {\n    // Any WebGroup options like for a client\n  }\n})\n\nbot.onWebGroup = (wg) => {\n  // New instance of a WebGroup (Someone has invited this bot).\n  // See example above for client as it is the same API.\n}\n\nserver.listen(BOT_PORT, _BOT_HOST)\n// A client may invite this bot with the following URL: 'ws://BOT_HOST:BOT_PORT'\n```\n\n## Demo\n\nNetflux is used by our team for Multi User Text Editor ([MUTE repo](https://github.com/coast-team/mute)) development. The demo version is available on: https://coedit.re\n\n[WebSocket]: https://developer.mozilla.org/en/docs/Web/API/WebSocket\n[RTCDataChannel]: https://developer.mozilla.org/en/docs/Web/API/RTCDataChannel\n[String]: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String\n[Uint8Array]: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array\n[Sigver]: https://github.com/coast-team/sigver\n\n[commitizen]: https://img.shields.io/badge/commitizen-friendly-brightgreen.svg?style=flat-square\n[commitizen-url]: http://commitizen.github.io/cz-cli\n\n[bithound]: https://www.bithound.io/github/coast-team/netflux/badges/score.svg\n[bithound-url]: https://www.bithound.io/github/coast-team/netflux\n\n[codeclimate]: https://codeclimate.com/github/coast-team/netflux/badges/gpa.svg\n[codeclimate-url]: https://codeclimate.com/github/coast-team/netflux\n\n[coverage]: https://codeclimate.com/github/coast-team/netflux/badges/coverage.svg\n[coverage-url]: https://codeclimate.com/github/coast-team/netflux/coverage\n\n[doc]: https://coast-team.github.io/netflux/badge.svg\n[doc-url]: https://coast-team.github.io/netflux/netflux\n\n[logo]: manual/asset/logo_cropped.png \"Netflux logo\"\n",
    "longname": "/home/philippe/workspace/netflux/manual/index.md",
    "name": "./manual/index.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manualAsset",
    "longname": "/home/philippe/workspace/netflux/manual/asset",
    "name": "./manual/asset",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/philippe/workspace/netflux/manual/installation.md",
    "name": "./manual/installation.md",
    "content": "# Installation\n\n## NPM\n\n```shell\nnpm install -S netflux\n```\n\nNetflux has an optional peer dependency: `wrtc`. This package provides WebRTC API in NodeJS, but for now it is not in use as more tests needed. Checkout [wrtc repository](https://github.com/js-platform/node-webrtc) for more info on it.\n\n## What you need\n\nSignaling server is the only mandatory server for Netflux, but for a fully functional peer to peer network which suits all use cases you also need STUN and TURN servers.\n\n> Netflux comes with Signaling and STUN servers by default for easier quickstart.\n\n### Signaling server\n\n> **Default**: `wss://signaling.netflux.coedit.re`\n\nThe only signaling mechanism which is supported by Netflux for now is [Sigver](https://github.com/coast-team/sigver) (NodeJS WebSocket server developed by us).\n\n> **TIP**: Your own instance of Sigver for production is recommended.\n\n### STUN server\n\n**Default**: `stun:stun3.l.google.com:19302`\n\nThere are many other free STUN servers available in the Web.\n\n### TURN server\n\nThere are no free TURN servers available in the Web. Two solutions exist:\n\n- Rent one. Checkout [Xirsys](https://xirsys.com/) for example.\n- Deploy your own instance. The paragraphe below provides a guide on how to deploy and configure [`coturn`](https://github.com/coturn/coturn) open source TURN server. Also checkout [*Choosing a TURN server*](https://rtcquickstart.org/guide/multi/turn-server-choice.html) for a list of open source TURN servers.\n\n## How to deploy STUN/TURN servers\n\nThis guide present a basic configuration for [coturn](https://github.com/coturn/coturn).\nIt allow us to deploy our own STUN/TURN server in order to connect users behind a NAT or Firewall.\n\nFor more informations or options, see coturn [documentation](https://github.com/coturn/coturn/wiki/README).\n\nOn most Linux Distribution, the package is in the repo:\n`apt-get install coturn`\n\nYou must have SQLite installed:\n`sudo apt-get install sqlite3 libsqlite3-dev`\n\nConfig file can be found at:\n`/etc/turnserver.conf`\n\nSimple config file should look like this:\n\n```bash\n# you can listen ports 3478 and 5349 instead of 80/443\nlistening-port=80\ntls-listening-port=443\n\nlistening-ip=YOUR_IP_ADDRESS\nrelay-ip=YOUR_IP_ADDRESS\n\nrealm=YOUR_DOMAIND.COM\nserver-name=OUR_DOMAIND.COM\n\nfingerprint\n\n# webRTC authentication method\nlt-cred-mech\n\n# WebRTC credentials\nuser=YOUR_USER_NAME:YOUR_PASSWORD\n\n# Quota\ntotal-quota=100\nbps-capacity=0\nstable-nonce\n\n# Add ssl certificate for your server\ncert=/etc/ssl/certificate.pem\npkey=/etc/ssl/private.key\ncipher-list=\"ECDH+AESGCM:DH+AESGCM:ECDH+AES256:DH+AES256:ECDH+AES128:!DH+AES:!ECDH+3DES:!DH+3DES:!RSA+AES:!RSA+3DES:!ADH:!AECDH:!MD5\"\nno-loopback-peers\nno-multicast-peers\nno-stdout-log\n```\n\nIf you don't have any SSL certificate, you may use [Let's Encrypt](https://letsencrypt.org/).\n\nLaunch server:\n\n```turnserver`\n\nor in daemon:\n\n`turnserver -o`\n\nVerify that the server is up and running with [Trickle ICE](https://webrtc.github.io/samples/src/content/peerconnection/trickle-ice/).\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/philippe/workspace/netflux/manual/usage.md",
    "name": "./manual/usage.md",
    "content": "# Usage\n\nThere are 4 builds (all ES5 code):\n\n- `dist/netflux.cjs.js` CommonJS format for NodeJS.\n- `dist/esm/netflux.node.js` ECMAScript 6 module format for NodeJS.\n- `dist/esm/netflux.browser.js` ECMAScript 6 module format for browsers.\n- `dist/netflux.umd.js` UMD format for browsers.\n\nThe `package.json` contains the following fields:\n\n```json\n...\n\"main\": \"dist/netflux.cjs.js\",\n\"module\": \"dist/esm/index.node.js\",\n\"browser\": \"dist/esm/index.browser.js\",\n...\n```\n\nAll builds are either for NodeJS or for Browser environment.\n\n**For browser environment** exported members are:\n\n- `WebGroup` class\n- `WebGroupState` enum\n- `SignalingState` enum\n- `Topology` enum\n- `DataType` type\n- `WebGroupOption` type\n\n**For NodeJS environment** exported members are the same as for browser plus:\n\n- `WebGroupBotServer` class\n- `WebGroupBotServerOptions` type.\n\n## CommonJS\n\n`dist/netflux.cjs.js` - CommonJS format, built for NodeJS.\n\n```Javascript\n// NodeJS\nconst netflux = require('netflux')\nvar wg = new netflux.WebGroup()\n```\n\n## ES module\n\n`esm/index.node.js` and `esm/index.browser.js` are suitable for Webpack, Browserify or any alike, which also undersands `package.json#module` and `package.json#module` properties respectively and can parse ES modules.\n\n`esm/index.node.js` is build for NodeJS: contains all exported API members and all necessary polyfills for NodeJS environment.\n\n`esm/index.browser.js`  si build for browsers.\n\n```javascript\nexport {WebGroup, WebGroupState, WebGroupBotServer, WebGroupBotServerOptions} from 'netflux'\nconst wg = new WebGroup()\n```\n\n## UMD\n\n`dist/netflux.umd.js` - Universal Module Definition format is compatible with AMD, CommonJS and \"global\" modules. Built for browser and suitable for Webpack, Browserify and any other who\nalso understands `package.json#browser` property.\n\n```html\n<!-- Browser global usage example -->\n<script src=\"netflux.es5.umd.js\">\n  window.netflux !== undefined // true\n  var wg = new window.netflux.WebGroup()\n</script>\n```\n\n## Configuration\n\nFor a `WebGroup` object all options are optional.\n\n```javascript\n// Example:\nconst wg = new WebGroup({\n  signalingURL: 'MY_SIGNALING_URL',\n  rtcConfiguration: {\n    iceServers: [\n      { urls: 'stun:mystun.org' },\n      {\n        urls: ['turn:myturn.org?transport=udp', 'turn:myturn.org?transport=tcp'],\n        username: 'user',\n        password: 'password'\n      }\n    ]\n  }\n})\n```\n\nFor `WebGroupBotServer` the server option is mandatory.\n\n```javascript\n// Example:\nconst http = require('http')\nconst myServer = http.createServer()\nconst wg = new WebGroupBotServer({\n  server: myServer,\n  signalingServer: 'MY_SIGNALING_URL',\n  webGroupOptions: {\n    rtcConfiguration: {\n    iceServers: [\n      { urls: 'stun:mystun.org' },\n      {\n        urls: ['turn:myturn.org?transport=udp', 'turn:myturn.org?transport=tcp'],\n        username: 'user',\n        password: 'password'\n      }\n    ]\n  }\n  }\n})\n```\n",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/philippe/workspace/netflux/manual/knownobstacles.md",
    "name": "./manual/knownobstacles.md",
    "content": "# Known WebRTC obstacles\n\nConnection establishment over WebRTC may ancounter different obstacles like NAT, Firewall, port blocking. But besides network obstacles there is also browser configuration that may prevent from connection creation.\n\n## Firefox extensions\n\nSome extensions for Firefox (Privacy Badger for instance) modify WebRTC configuration in browser. Checkout `about:config` and look for `peerconnection.ice`. If the *Status* column is *default* then the parameter was not modified.",
    "static": true,
    "access": "public"
  },
  {
    "__docId__": 79,
    "kind": "testFile",
    "name": "test/functional/1member.test.js",
    "content": "/// <reference types='jasmine' />\nimport { SignalingState, Topology, WebGroup, WebGroupState } from '../../src/index.browser';\nimport { areTheSame, cleanWebGroup, SIGNALING_URL, wait } from '../util/helper';\nconst WebGroupOptions = {\n    signalingServer: SIGNALING_URL,\n    autoRejoin: false,\n};\n/** @test {WebGroup} */\ndescribe('1 member', () => {\n    describe('🙂', () => {\n        let wg1;\n        /** @test {WebGroup#constructor} */\n        it('constructor', () => {\n            const wg = new WebGroup({ signalingServer: SIGNALING_URL });\n            // Check members\n            const id = Reflect.getOwnPropertyDescriptor(wg, 'id');\n            expect(id).toBeDefined();\n            expect(typeof wg.id).toBe('number');\n            expect(id.set).toBeUndefined();\n            const myId = Reflect.getOwnPropertyDescriptor(wg, 'myId');\n            expect(myId).toBeDefined();\n            expect(typeof wg.myId).toBe('number');\n            expect(myId.set).toBeUndefined();\n            const key = Reflect.getOwnPropertyDescriptor(wg, 'key');\n            expect(key).toBeDefined();\n            expect(wg.key).toBe('');\n            expect(key.set).toBeUndefined();\n            const members = Reflect.getOwnPropertyDescriptor(wg, 'members');\n            expect(members).toBeDefined();\n            expect(wg.members).toEqual([wg.myId]);\n            expect(members.set).toBeUndefined();\n            const topology = Reflect.getOwnPropertyDescriptor(wg, 'topology');\n            expect(topology).toBeDefined();\n            expect(wg.topology).toBe(Topology.FULL_MESH);\n            expect(topology.set).toBeUndefined();\n            const state = Reflect.getOwnPropertyDescriptor(wg, 'state');\n            expect(state).toBeDefined();\n            expect(wg.state).toBe(WebGroupState.LEFT);\n            expect(state.set).toBeUndefined();\n            const signalingState = Reflect.getOwnPropertyDescriptor(wg, 'signalingState');\n            expect(signalingState).toBeDefined();\n            expect(wg.signalingState).toBe(SignalingState.CLOSED);\n            expect(signalingState.set).toBeUndefined();\n            const signalingServer = Reflect.getOwnPropertyDescriptor(wg, 'signalingServer');\n            expect(signalingServer).toBeDefined();\n            expect(wg.signalingServer).toBe(SIGNALING_URL);\n            expect(signalingServer.set).toBeUndefined();\n            expect(wg.autoRejoin).toBeTruthy();\n            wg.autoRejoin = false;\n            expect(wg.autoRejoin).toBeFalsy();\n            // Check event handlers\n            expect(wg.onMemberJoin).toBeUndefined();\n            expect(wg.onMemberLeave).toBeUndefined();\n            expect(wg.onMessage).toBeUndefined();\n            expect(wg.onStateChange).toBeUndefined();\n            expect(wg.onSignalingStateChange).toBeUndefined();\n            // Check methods\n            expect(typeof wg.join).toBe('function');\n            expect(typeof wg.invite).toBe('function');\n            expect(typeof wg.leave).toBe('function');\n            expect(typeof wg.send).toBe('function');\n            expect(typeof wg.sendTo).toBe('function');\n        });\n        /** @test {WebGroup#join} */\n        describe('joining', () => {\n            beforeEach(() => {\n                wg1 = new WebGroup(WebGroupOptions);\n            });\n            afterEach((done) => {\n                cleanWebGroup(wg1);\n                if (wg1.state !== WebGroupState.LEFT) {\n                    wg1.onStateChange = (state) => {\n                        if (state === WebGroupState.LEFT) {\n                            done();\n                        }\n                    };\n                    wg1.leave();\n                }\n                else {\n                    cleanWebGroup(wg1);\n                    done();\n                }\n            });\n            /** @test {WebGroup#onSignalingStateChange} */\n            it('should change the Signaling state', (done) => {\n                let called1 = 0;\n                const states = [];\n                const expectedStates = [SignalingState.CONNECTING, SignalingState.STABLE];\n                wg1.onSignalingStateChange = (state) => {\n                    states.push(state);\n                    called1++;\n                    if (called1 === 2) {\n                        wait(1000).then(() => {\n                            expect(called1).toEqual(2);\n                            expect(states).toEqual(expectedStates);\n                            expect(wg1.signalingState).toEqual(SignalingState.STABLE);\n                            done();\n                        });\n                    }\n                };\n                // Start joining\n                wg1.join();\n            });\n            /** @test {WebGroup#onStateChange} */\n            it('should change the WebGroup state', (done) => {\n                let called1 = 0;\n                const states = [];\n                const expectedStates = [WebGroupState.JOINING, WebGroupState.JOINED];\n                wg1.onStateChange = (state) => {\n                    states.push(state);\n                    called1++;\n                    if (called1 === 2) {\n                        wait(1000).then(() => {\n                            expect(called1).toEqual(2);\n                            expect(states).toEqual(expectedStates);\n                            expect(wg1.state).toEqual(WebGroupState.JOINED);\n                            done();\n                        });\n                    }\n                };\n                // Start joining\n                wg1.join();\n            });\n            /** @test {WebGroup#onMemberJoin} */\n            it('should NOT be notified about new member', (done) => {\n                let called1 = 0;\n                wg1.onMemberJoin = () => called1++;\n                wg1.onStateChange = (state) => {\n                    if (state === WebGroupState.JOINED) {\n                        wait(1000)\n                            .then(() => {\n                            expect(called1).toEqual(0);\n                            done();\n                        });\n                    }\n                };\n                // Start joining\n                wg1.join();\n            });\n            it('should have the same members, WebGroup id, topology and NOT empty key once joined', (done) => {\n                const members = Array.from(wg1.members);\n                const myId = wg1.myId;\n                const id = wg1.id;\n                const topology = wg1.topology;\n                wg1.onStateChange = (state) => {\n                    if (state === WebGroupState.JOINED) {\n                        expect(areTheSame(wg1.members, members)).toBeTruthy();\n                        expect(myId).toEqual(wg1.myId);\n                        expect(id).toEqual(wg1.id);\n                        expect(topology).toEqual(wg1.topology);\n                        expect(wg1.key).not.toEqual('');\n                        wait(1000)\n                            .then(() => {\n                            expect(areTheSame(wg1.members, members)).toBeTruthy();\n                            expect(myId).toEqual(wg1.myId);\n                            expect(id).toEqual(wg1.id);\n                            expect(topology).toEqual(wg1.topology);\n                            expect(wg1.key).not.toEqual('');\n                            done();\n                        });\n                    }\n                };\n                // Start joining\n                wg1.join();\n            });\n            /** @test {WebGroup#join} */\n            it('should join with the specified key', (done) => {\n                const key = 'ArtIsLongLifeIsShort';\n                const wg = new WebGroup(WebGroupOptions);\n                wg.onStateChange = (state) => {\n                    if (state === WebGroupState.JOINED) {\n                        expect(wg.key).toEqual(key);\n                        wg.leave();\n                        done();\n                    }\n                };\n                // Start joining\n                wg.join(key);\n            });\n        });\n        describe('leaving', () => {\n            beforeEach((done) => {\n                wg1 = new WebGroup(WebGroupOptions);\n                wg1.onStateChange = (state) => {\n                    if (state === WebGroupState.JOINED) {\n                        cleanWebGroup(wg1);\n                        done();\n                    }\n                };\n                wg1.join();\n            });\n            afterEach(() => cleanWebGroup(wg1));\n            /** @test {WebGroup#leave} */\n            it('should have the same members, WebGroup id, topology and an empty key', (done) => {\n                const members = Array.from(wg1.members);\n                const myId = wg1.myId;\n                const id = wg1.id;\n                const topology = wg1.topology;\n                wg1.onStateChange = (state) => {\n                    if (state === WebGroupState.LEFT) {\n                        expect(areTheSame(wg1.members, members)).toBeTruthy();\n                        expect(myId).toEqual(wg1.myId);\n                        expect(id).toEqual(wg1.id);\n                        expect(topology).toEqual(wg1.topology);\n                        expect(wg1.key).toEqual('');\n                        wait(1000)\n                            .then(() => {\n                            expect(areTheSame(wg1.members, members)).toBeTruthy();\n                            expect(myId).toEqual(wg1.myId);\n                            expect(id).toEqual(wg1.id);\n                            expect(topology).toEqual(wg1.topology);\n                            expect(wg1.key).toEqual('');\n                            done();\n                        });\n                    }\n                };\n                // Start leaving\n                wg1.leave();\n            });\n            /** @test {WebGroup#onMemberLeave} */\n            it('should be NOT notified about left member', (done) => {\n                let called1 = 0;\n                wg1.onMemberJoin = () => called1++;\n                wg1.onStateChange = (state) => {\n                    if (state === WebGroupState.LEFT) {\n                        wait(1000)\n                            .then(() => {\n                            expect(called1).toEqual(0);\n                            done();\n                        });\n                    }\n                };\n                // Start leaving\n                wg1.leave();\n            });\n            /** @test {WebGroup#onStateChange} */\n            it('should change the WebGroup state', (done) => {\n                let called1 = 0;\n                const states = [];\n                const expectedStates = [WebGroupState.LEAVING, WebGroupState.LEFT];\n                wg1.onStateChange = (state) => {\n                    states.push(state);\n                    called1++;\n                    if (state === WebGroupState.LEFT) {\n                        wait(1000)\n                            .then(() => {\n                            expect(called1).toEqual(2);\n                            expect(states).toEqual(expectedStates);\n                            expect(state).toEqual(WebGroupState.LEFT);\n                            done();\n                        });\n                    }\n                };\n                // Start leaving\n                wg1.leave();\n            });\n            /** @test {WebGroup#onSignalingStateChange} */\n            it('should change the Signaling state', (done) => {\n                let called1 = 0;\n                const states = [];\n                const expectedStates = [SignalingState.CLOSING, SignalingState.CLOSED];\n                wg1.onSignalingStateChange = (state) => {\n                    states.push(state);\n                    called1++;\n                    wait(1000)\n                        .then(() => {\n                        expect(called1).toEqual(2);\n                        expect(states).toEqual(expectedStates);\n                        done();\n                    });\n                };\n                // Start leaving\n                wg1.leave();\n            });\n        });\n    });\n});\n",
    "static": true,
    "longname": "/home/philippe/workspace/netflux/docs/jsFromTs/test/functional/1member.test.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 80,
    "kind": "test",
    "name": "describe0",
    "testId": 0,
    "memberof": "test/functional/1member.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/functional/1member.test.js~describe0",
    "access": null,
    "description": "1 member",
    "lineNumber": 9,
    "testTargets": [
      "WebGroup"
    ]
  },
  {
    "__docId__": 81,
    "kind": "test",
    "name": "describe1",
    "testId": 1,
    "memberof": "test/functional/1member.test.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/functional/1member.test.js~describe0.describe1",
    "access": null,
    "description": "🙂",
    "lineNumber": 10
  },
  {
    "__docId__": 82,
    "kind": "test",
    "name": "it2",
    "testId": 2,
    "memberof": "test/functional/1member.test.js~describe0.describe1",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1member.test.js~describe0.describe1.it2",
    "access": null,
    "description": "constructor",
    "lineNumber": 13,
    "testTargets": [
      "WebGroup#constructor"
    ]
  },
  {
    "__docId__": 83,
    "kind": "test",
    "name": "describe3",
    "testId": 3,
    "memberof": "test/functional/1member.test.js~describe0.describe1",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1member.test.js~describe0.describe1.describe3",
    "access": null,
    "description": "joining",
    "lineNumber": 65,
    "testTargets": [
      "WebGroup#join"
    ]
  },
  {
    "__docId__": 84,
    "kind": "test",
    "name": "it4",
    "testId": 4,
    "memberof": "test/functional/1member.test.js~describe0.describe1.describe3",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/1member.test.js~describe0.describe1.describe3.it4",
    "access": null,
    "description": "should change the Signaling state",
    "lineNumber": 85,
    "testTargets": [
      "WebGroup#onSignalingStateChange"
    ]
  },
  {
    "__docId__": 85,
    "kind": "test",
    "name": "it5",
    "testId": 5,
    "memberof": "test/functional/1member.test.js~describe0.describe1.describe3",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/1member.test.js~describe0.describe1.describe3.it5",
    "access": null,
    "description": "should change the WebGroup state",
    "lineNumber": 105,
    "testTargets": [
      "WebGroup#onStateChange"
    ]
  },
  {
    "__docId__": 86,
    "kind": "test",
    "name": "it6",
    "testId": 6,
    "memberof": "test/functional/1member.test.js~describe0.describe1.describe3",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/1member.test.js~describe0.describe1.describe3.it6",
    "access": null,
    "description": "should NOT be notified about new member",
    "lineNumber": 125,
    "testTargets": [
      "WebGroup#onMemberJoin"
    ]
  },
  {
    "__docId__": 87,
    "kind": "test",
    "name": "it7",
    "testId": 7,
    "memberof": "test/functional/1member.test.js~describe0.describe1.describe3",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/1member.test.js~describe0.describe1.describe3.it7",
    "access": null,
    "description": "should have the same members, WebGroup id, topology and NOT empty key once joined",
    "lineNumber": 140
  },
  {
    "__docId__": 88,
    "kind": "test",
    "name": "it8",
    "testId": 8,
    "memberof": "test/functional/1member.test.js~describe0.describe1.describe3",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/1member.test.js~describe0.describe1.describe3.it8",
    "access": null,
    "description": "should join with the specified key",
    "lineNumber": 167,
    "testTargets": [
      "WebGroup#join"
    ]
  },
  {
    "__docId__": 89,
    "kind": "test",
    "name": "describe9",
    "testId": 9,
    "memberof": "test/functional/1member.test.js~describe0.describe1",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/1member.test.js~describe0.describe1.describe9",
    "access": null,
    "description": "leaving",
    "lineNumber": 181
  },
  {
    "__docId__": 90,
    "kind": "test",
    "name": "it10",
    "testId": 10,
    "memberof": "test/functional/1member.test.js~describe0.describe1.describe9",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/1member.test.js~describe0.describe1.describe9.it10",
    "access": null,
    "description": "should have the same members, WebGroup id, topology and an empty key",
    "lineNumber": 194,
    "testTargets": [
      "WebGroup#leave"
    ]
  },
  {
    "__docId__": 91,
    "kind": "test",
    "name": "it11",
    "testId": 11,
    "memberof": "test/functional/1member.test.js~describe0.describe1.describe9",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/1member.test.js~describe0.describe1.describe9.it11",
    "access": null,
    "description": "should be NOT notified about left member",
    "lineNumber": 221,
    "testTargets": [
      "WebGroup#onMemberLeave"
    ]
  },
  {
    "__docId__": 92,
    "kind": "test",
    "name": "it12",
    "testId": 12,
    "memberof": "test/functional/1member.test.js~describe0.describe1.describe9",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/1member.test.js~describe0.describe1.describe9.it12",
    "access": null,
    "description": "should change the WebGroup state",
    "lineNumber": 237,
    "testTargets": [
      "WebGroup#onStateChange"
    ]
  },
  {
    "__docId__": 93,
    "kind": "test",
    "name": "it13",
    "testId": 13,
    "memberof": "test/functional/1member.test.js~describe0.describe1.describe9",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/1member.test.js~describe0.describe1.describe9.it13",
    "access": null,
    "description": "should change the Signaling state",
    "lineNumber": 258,
    "testTargets": [
      "WebGroup#onSignalingStateChange"
    ]
  },
  {
    "__docId__": 94,
    "kind": "testFile",
    "name": "test/functional/2members.test.js",
    "content": "/// <reference types='jasmine' />\n/* tslint:disable:one-variable-per-declaration */\nimport { SignalingState, WebGroup, WebGroupState } from '../../src/index.browser';\nimport { areTheSame, BOT_URL, cleanWebGroup, getBotData, Queue, SIGNALING_URL, wait, waitBotJoin } from '../util/helper';\nconst WebGroupOptions = {\n    signalingServer: SIGNALING_URL,\n    autoRejoin: false,\n};\n/** @test {WebGroup} */\ndescribe('2 members', () => {\n    describe('🙂 🙂', () => {\n        let wg1, wg2;\n        /** @test {WebGroup#join} */\n        describe('joining', () => {\n            beforeEach((done) => {\n                const queue = new Queue(2);\n                queue.wait().then(() => {\n                    cleanWebGroup(wg1);\n                    cleanWebGroup(wg2);\n                    done();\n                });\n                wg1 = new WebGroup(WebGroupOptions);\n                wg2 = new WebGroup(WebGroupOptions);\n                wg1.onSignalingStateChange = (state) => {\n                    if (state === SignalingState.STABLE) {\n                        queue.pop();\n                    }\n                };\n                wg1.onStateChange = (state) => {\n                    if (state === WebGroupState.JOINED) {\n                        queue.pop();\n                    }\n                };\n                wg1.join();\n            });\n            afterEach((done) => {\n                cleanWebGroup(wg1);\n                cleanWebGroup(wg2);\n                const queue = new Queue(2);\n                queue.wait().then(() => {\n                    cleanWebGroup(wg1);\n                    cleanWebGroup(wg2);\n                    done();\n                });\n                if (wg1.state !== WebGroupState.LEFT) {\n                    wg1.onStateChange = (state) => {\n                        if (state === WebGroupState.LEFT) {\n                            queue.pop();\n                        }\n                    };\n                    wg1.leave();\n                }\n                else {\n                    queue.pop();\n                }\n                if (wg2.state !== WebGroupState.LEFT) {\n                    wg2.onStateChange = (state) => {\n                        if (state === WebGroupState.LEFT) {\n                            queue.pop();\n                        }\n                    };\n                    wg2.leave();\n                }\n                else {\n                    queue.pop();\n                }\n            });\n            /** @test {WebGroup#onSignalingStateChange} */\n            it('should change the Signaling state', (done) => {\n                let called1 = 0, called2 = 0;\n                const states = [];\n                const expectedStates = [SignalingState.CONNECTING, SignalingState.CONNECTED, SignalingState.STABLE];\n                // Code for peer 1\n                wg1.onSignalingStateChange = () => called1++;\n                // Code for peer 2\n                wg2.onSignalingStateChange = (state) => {\n                    states.push(state);\n                    called2++;\n                    if (called2 === 3) {\n                        wait(1000).then(() => {\n                            expect(called1).toEqual(0);\n                            expect(called2).toEqual(3);\n                            expect(states).toEqual(expectedStates);\n                            expect(wg2.signalingState).toEqual(SignalingState.STABLE);\n                            done();\n                        });\n                    }\n                };\n                // Start joining\n                wg2.join(wg1.key);\n            });\n            /** @test {WebGroup#onStateChange} */\n            it('should change the WebGroup state', (done) => {\n                let called1 = 0, called2 = 0;\n                const states = [];\n                const expectedStates = [WebGroupState.JOINING, WebGroupState.JOINED];\n                // Code for peer 1\n                wg1.onStateChange = () => called1++;\n                // Code for peer 2\n                wg2.onStateChange = (state) => {\n                    states.push(state);\n                    called2++;\n                    if (called2 === 2) {\n                        wait(1000).then(() => {\n                            expect(called1).toEqual(0);\n                            expect(called2).toEqual(2);\n                            expect(states).toEqual(expectedStates);\n                            expect(wg2.state).toEqual(WebGroupState.JOINED);\n                            done();\n                        });\n                    }\n                };\n                // Start joining\n                wg2.join(wg1.key);\n            });\n            /** @test {WebGroup#onMemberJoin} */\n            it('should be notified about new member', (done) => {\n                let called1 = 0, called2 = 0;\n                const queue = new Queue(1);\n                // Code for peer 1\n                wg1.onMemberJoin = (id) => {\n                    expect(id).toEqual(wg2.myId);\n                    called1++;\n                    queue.pop();\n                };\n                // Code for peer 2\n                wg2.onMemberJoin = (id) => {\n                    expect(id).toEqual(wg1.myId);\n                    called2++;\n                };\n                wg2.onStateChange = (state) => {\n                    if (state === WebGroupState.JOINED) {\n                        queue.wait()\n                            .then(() => wait(1000))\n                            .then(() => {\n                            expect(called1).toEqual(1);\n                            expect(called2).toEqual(1);\n                            done();\n                        });\n                    }\n                };\n                // Start joining\n                wg2.join(wg1.key);\n            });\n            it('should have the same members, key, WebGroup id, topology once joined', (done) => {\n                const queue = new Queue(1);\n                // Code for peer 1\n                wg1.onMemberJoin = () => {\n                    expect(wg1.members.length).toEqual(2);\n                    expect(wg1.members.includes(wg1.myId)).toBeTruthy();\n                    expect(wg1.members.includes(wg2.myId)).toBeTruthy();\n                    queue.pop();\n                };\n                // Code for peer 2\n                wg2.onStateChange = (state) => {\n                    if (state === WebGroupState.JOINED) {\n                        expect(wg2.members.length).toEqual(2);\n                        expect(wg2.members.includes(wg1.myId)).toBeTruthy();\n                        expect(wg2.members.includes(wg2.myId)).toBeTruthy();\n                        expect(wg2.id).toEqual(wg1.id);\n                        expect(wg2.key).toEqual(wg1.key);\n                        expect(wg2.topology).toEqual(wg1.topology);\n                        queue.wait()\n                            .then(() => wait(1000))\n                            .then(() => {\n                            expect(areTheSame(wg2.members, wg1.members)).toBeTruthy();\n                            expect(wg2.id).toEqual(wg1.id);\n                            expect(wg2.key).toEqual(wg1.key);\n                            expect(wg2.topology).toEqual(wg1.topology);\n                            done();\n                        });\n                    }\n                };\n                // Start joining\n                wg2.join(wg1.key);\n            });\n            /** @test {WebGroup#join} */\n            it('should join with the specified key', (done) => {\n                const queue = new Queue(3);\n                const key = 'ArtIsLongLifeIsShort';\n                const wg = new WebGroup(WebGroupOptions);\n                // Code for peer 1\n                wg.onSignalingStateChange = (state) => {\n                    if (state === SignalingState.STABLE) {\n                        wg2.join(key);\n                    }\n                };\n                wg.onMemberJoin = () => queue.pop();\n                // Code for peer 2\n                wg2.onStateChange = (state) => {\n                    if (state === WebGroupState.JOINED) {\n                        expect(wg.key).toEqual(key);\n                        expect(wg2.key).toEqual(key);\n                        queue.pop();\n                    }\n                };\n                wg2.onMemberJoin = () => queue.pop();\n                // Start joining\n                wg.join(key);\n                queue.wait().then(() => {\n                    wg.leave();\n                    done();\n                });\n            });\n        });\n        describe('should send/receive', () => {\n            let called1, called2;\n            beforeEach((done) => {\n                called1 = 0;\n                called2 = 0;\n                const queue = new Queue(3);\n                queue.wait().then(() => {\n                    cleanWebGroup(wg1);\n                    cleanWebGroup(wg2);\n                    done();\n                });\n                wg1 = new WebGroup(WebGroupOptions);\n                wg2 = new WebGroup(WebGroupOptions);\n                wg1.onSignalingStateChange = (state) => {\n                    if (state === SignalingState.STABLE) {\n                        wg2.join(wg1.key);\n                    }\n                };\n                wg1.onMemberJoin = () => queue.pop();\n                wg2.onStateChange = (state) => {\n                    if (state === WebGroupState.JOINED) {\n                        queue.pop();\n                    }\n                };\n                wg2.onMemberJoin = () => queue.pop();\n                wg1.join();\n            });\n            afterEach((done) => {\n                cleanWebGroup(wg1);\n                cleanWebGroup(wg2);\n                const queue = new Queue(2);\n                queue.wait().then(() => {\n                    cleanWebGroup(wg1);\n                    cleanWebGroup(wg2);\n                    done();\n                });\n                if (wg1.state !== WebGroupState.LEFT) {\n                    wg1.onStateChange = (state) => {\n                        if (state === WebGroupState.LEFT) {\n                            queue.pop();\n                        }\n                    };\n                    wg1.leave();\n                }\n                else {\n                    queue.pop();\n                }\n                if (wg2.state !== WebGroupState.LEFT) {\n                    wg2.onStateChange = (state) => {\n                        if (state === WebGroupState.LEFT) {\n                            queue.pop();\n                        }\n                    };\n                    wg2.leave();\n                }\n                else {\n                    queue.pop();\n                }\n            });\n            /** @test {WebGroup#send} */\n            it('broadcast String', (done) => {\n                const msg1 = 'Art is long, life is short';\n                const msg2 = 'Do or do not, there is no try';\n                // Code for peer 1\n                wg1.onMessage = (id, msg) => {\n                    expect(id).toEqual(wg2.myId);\n                    expect(msg).toEqual(msg2);\n                    wg1.send(msg1);\n                    called1++;\n                };\n                // Code for peer 2\n                wg2.onMessage = (id, msg) => {\n                    expect(id).toEqual(wg1.myId);\n                    expect(msg).toEqual(msg1);\n                    called2++;\n                    wait(1000).then(() => {\n                        expect(called1).toEqual(1);\n                        expect(called2).toEqual(1);\n                        done();\n                    });\n                };\n                // Start sending message\n                wg2.send(msg2);\n            });\n            /** @test {WebGroup#send} */\n            it('broadcast ArrayBuffer', (done) => {\n                const msg1 = new Uint8Array([42, 347, 248247, 583, 10, 8, 9623]);\n                const msg2 = new Uint8Array([845, 4, 798240, 3290, 553, 1, 398539857, 84]);\n                // Code for peer 1\n                wg1.onMessage = (id, msg) => {\n                    expect(id).toEqual(wg2.myId);\n                    expect(msg instanceof Uint8Array);\n                    expect(msg).toEqual(msg2);\n                    wg1.send(msg1);\n                    called1++;\n                };\n                // Code for peer 2\n                wg2.onMessage = (id, msg) => {\n                    expect(id).toEqual(wg1.myId);\n                    expect(msg instanceof Uint8Array);\n                    expect(msg).toEqual(msg1);\n                    called2++;\n                    wait(1000).then(() => {\n                        expect(called1).toEqual(1);\n                        expect(called2).toEqual(1);\n                        done();\n                    });\n                };\n                // Start sending message\n                wg2.send(msg2);\n            });\n            /** @test {WebGroup#sendTo} */\n            it('private String', (done) => {\n                const msg1 = 'Art is long, life is short';\n                const msg2 = 'Do or do not, there is no try';\n                // Code for peer 1\n                wg1.onMessage = (id, msg) => {\n                    expect(id).toEqual(wg2.myId);\n                    expect(msg).toEqual(msg2);\n                    wg1.sendTo(wg2.myId, msg1);\n                    called1++;\n                };\n                // Code for peer 2\n                wg2.onMessage = (id, msg) => {\n                    expect(id).toEqual(wg1.myId);\n                    expect(msg).toEqual(msg1);\n                    called2++;\n                    wait(1000).then(() => {\n                        expect(called1).toEqual(1);\n                        expect(called2).toEqual(1);\n                        done();\n                    });\n                };\n                // Start sending message\n                wg2.sendTo(wg1.myId, msg2);\n            });\n            /** @test {WebGroup#sendTo} */\n            it('private ArrayBuffer', (done) => {\n                const msg1 = new Uint8Array([42, 347, 248247, 583, 10, 8, 9623]);\n                const msg2 = new Uint8Array([845, 4, 798240, 3290, 553, 1, 398539857, 84]);\n                // Code for peer 1\n                wg1.onMessage = (id, msg) => {\n                    expect(id).toEqual(wg2.myId);\n                    expect(msg instanceof Uint8Array);\n                    expect(msg).toEqual(msg2);\n                    wg1.sendTo(wg2.myId, msg1);\n                    called1++;\n                };\n                // Code for peer 2\n                wg2.onMessage = (id, msg) => {\n                    expect(id).toEqual(wg1.myId);\n                    expect(msg instanceof Uint8Array);\n                    expect(msg).toEqual(msg1);\n                    called2++;\n                    wait(1000).then(() => {\n                        expect(called1).toEqual(1);\n                        expect(called2).toEqual(1);\n                        done();\n                    });\n                };\n                // Start sending message\n                wg2.sendTo(wg1.myId, msg2);\n            });\n        });\n        describe('leaving', () => {\n            let called1, called2;\n            beforeEach((done) => {\n                called1 = 0;\n                called2 = 0;\n                const queue = new Queue(3);\n                queue.wait().then(() => {\n                    cleanWebGroup(wg1);\n                    cleanWebGroup(wg2);\n                    done();\n                });\n                wg1 = new WebGroup(WebGroupOptions);\n                wg2 = new WebGroup(WebGroupOptions);\n                wg1.onSignalingStateChange = (state) => {\n                    if (state === SignalingState.STABLE) {\n                        wg2.join(wg1.key);\n                    }\n                };\n                wg1.onMemberJoin = () => queue.pop();\n                wg2.onStateChange = (state) => {\n                    if (state === WebGroupState.JOINED) {\n                        queue.pop();\n                    }\n                };\n                wg2.onMemberJoin = () => queue.pop();\n                wg1.join();\n            });\n            afterEach((done) => {\n                cleanWebGroup(wg1);\n                cleanWebGroup(wg2);\n                const queue = new Queue(2);\n                queue.wait().then(() => {\n                    cleanWebGroup(wg1);\n                    cleanWebGroup(wg2);\n                    wait(1000).then(done);\n                });\n                if (wg1.state !== WebGroupState.LEFT) {\n                    wg1.onStateChange = (state) => {\n                        if (state === WebGroupState.LEFT) {\n                            queue.pop();\n                        }\n                    };\n                    wg1.leave();\n                }\n                else {\n                    queue.pop();\n                }\n                if (wg2.state !== WebGroupState.LEFT) {\n                    wg2.onStateChange = (state) => {\n                        if (state === WebGroupState.LEFT) {\n                            queue.pop();\n                        }\n                    };\n                    wg2.leave();\n                }\n                else {\n                    queue.pop();\n                }\n            });\n            /** @test {WebGroup#leave} */\n            it('should have no members & an empty key', (done) => {\n                const queue = new Queue(2);\n                queue.wait()\n                    .then(() => wait(1000))\n                    .then(() => {\n                    expect(wg1.members.length).toEqual(1);\n                    expect(wg1.members.includes(wg1.myId)).toBeTruthy();\n                    expect(wg2.members.length).toEqual(1);\n                    expect(wg2.members.includes(wg2.myId)).toBeTruthy();\n                    expect(wg2.key).toEqual('');\n                    expect(called2).toEqual(1);\n                    expect(wg2.key).toEqual('');\n                    done();\n                });\n                // Code for peer 1\n                wg1.onMemberLeave = () => {\n                    expect(wg1.members.length).toEqual(1);\n                    expect(wg1.members.includes(wg1.myId)).toBeTruthy();\n                    queue.pop();\n                };\n                // Code for peer 2\n                wg2.onStateChange = (state) => {\n                    if (state === WebGroupState.LEFT) {\n                        called2++;\n                        expect(wg2.members.length).toEqual(1);\n                        expect(wg2.members.includes(wg2.myId)).toBeTruthy();\n                        expect(wg2.key).toEqual('');\n                        queue.pop();\n                    }\n                };\n                // Start leaving\n                wg2.leave();\n            }, 12000);\n            /** @test {WebGroup#onMemberLeave} */\n            it('should be notified about left member', (done) => {\n                const queue = new Queue(2);\n                queue.wait().then(() => {\n                    wait(1000).then(() => {\n                        expect(called1).toEqual(1);\n                        expect(called2).toEqual(1);\n                        done();\n                    });\n                });\n                // Code for peer 1\n                wg1.onMemberLeave = (id) => {\n                    expect(id).toEqual(wg2.myId);\n                    called1++;\n                    queue.pop();\n                };\n                // Code for peer 2\n                wg2.onMemberLeave = (id) => {\n                    expect(id).toEqual(wg1.myId);\n                    called2++;\n                    queue.pop();\n                };\n                // Start leaving\n                wg2.leave();\n            }, 12000);\n            /** @test {WebGroup#onStateChange} */\n            it('should change the WebGroup state', (done) => {\n                const states = [];\n                const expectedStates = [WebGroupState.LEAVING, WebGroupState.LEFT];\n                // Code for peer 2\n                wg2.onStateChange = (state) => {\n                    states.push(state);\n                    called2++;\n                    if (state === WebGroupState.LEFT) {\n                        wait(1000).then(() => {\n                            expect(called2).toEqual(2);\n                            expect(states).toEqual(expectedStates);\n                            done();\n                        });\n                    }\n                };\n                // Start leaving\n                wg2.leave();\n            }, 12000);\n            /** @test {WebGroup#onSignalingStateChange} */\n            it('should change the Signaling state', (done) => {\n                const states = [];\n                const expectedStates = [SignalingState.CLOSING, SignalingState.CLOSED];\n                // Code for peer 2\n                wg2.onSignalingStateChange = (state) => {\n                    states.push(state);\n                    called2++;\n                    if (state === SignalingState.CLOSED) {\n                        wait(1000).then(() => {\n                            expect(called2).toEqual(2);\n                            expect(states).toEqual(expectedStates);\n                            done();\n                        });\n                    }\n                };\n                // Start leaving\n                wg2.leave();\n            }, 12000);\n        });\n    });\n    describe('🙂 🤖', () => {\n        let wg1;\n        /** @test {WebGroup#invite} */\n        describe('inviting', () => {\n            beforeEach(() => wg1 = new WebGroup(WebGroupOptions));\n            afterEach((done) => {\n                cleanWebGroup(wg1);\n                if (wg1.state !== WebGroupState.LEFT) {\n                    wg1.onStateChange = (state) => {\n                        if (state === WebGroupState.LEFT) {\n                            cleanWebGroup(wg1);\n                            done();\n                        }\n                    };\n                    wg1.leave();\n                }\n                else {\n                    cleanWebGroup(wg1);\n                    done();\n                }\n            });\n            /** @test {WebGroup#onSignalingStateChange} */\n            it('should not change the Signaling state', (done) => {\n                // Code for peer 1\n                wg1.onSignalingStateChange = (state) => {\n                    if (state === SignalingState.STABLE) {\n                        // Start inviting\n                        wg1.invite(BOT_URL);\n                        // Check bot data\n                        waitBotJoin(wg1.id)\n                            .then(() => wait(1000))\n                            .then(() => getBotData(wg1.id))\n                            .then((data) => {\n                            expect(data.onSignalingStateCalled).toEqual(0);\n                            expect(data.signalingState).toEqual(SignalingState.CLOSED);\n                            done();\n                        });\n                    }\n                };\n                // Start joining\n                wg1.join();\n            });\n            /** @test {WebGroup#onStateChange} */\n            it('should change the WebGroup state', (done) => {\n                // Code for peer 1\n                wg1.onSignalingStateChange = (state) => {\n                    if (state === SignalingState.STABLE) {\n                        // Start inviting\n                        wg1.invite(BOT_URL);\n                        // Check bot data\n                        waitBotJoin(wg1.id)\n                            .then(() => wait(1000))\n                            .then(() => getBotData(wg1.id))\n                            .then((data) => {\n                            expect(data.state).toEqual(WebGroupState.JOINED);\n                            done();\n                        })\n                            .catch(fail);\n                    }\n                };\n                // Start joining\n                wg1.join();\n            });\n            /** @test {WebGroup#onMemberJoin} */\n            it('should be notified about new member', (done) => {\n                let called1 = 0;\n                // Code for peer 1\n                wg1.onSignalingStateChange = (state) => {\n                    if (state === SignalingState.STABLE) {\n                        // Start inviting\n                        wg1.invite(BOT_URL);\n                    }\n                };\n                wg1.onMemberJoin = (id) => {\n                    called1++;\n                    // Check bot data\n                    waitBotJoin(wg1.id)\n                        .then(() => wait(1000))\n                        .then(() => getBotData(wg1.id))\n                        .then((bot) => {\n                        expect(id).toEqual(bot.myId);\n                        expect(bot.onMemberJoinCalled).toEqual(1);\n                        expect(bot.joinedMembers.length).toEqual(1);\n                        expect(bot.joinedMembers[0]).toEqual(wg1.myId);\n                        expect(called1).toEqual(1);\n                        done();\n                    })\n                        .catch(fail);\n                };\n                // Start joining\n                wg1.join();\n            });\n            it('should have the same members, WebGroup id, topology once joined', (done) => {\n                // Code for peer 1\n                wg1.onSignalingStateChange = (state) => {\n                    if (state === SignalingState.STABLE) {\n                        // Start inviting\n                        wg1.invite(BOT_URL);\n                    }\n                };\n                wg1.onMemberJoin = () => {\n                    // Check bot data\n                    waitBotJoin(wg1.id)\n                        .then(() => wait(1000))\n                        .then(() => getBotData(wg1.id))\n                        .then((bot) => {\n                        expect(areTheSame(bot.members, wg1.members)).toBeTruthy();\n                        expect(bot.key).toEqual('');\n                        expect(bot.topology).toEqual(wg1.topology);\n                        expect(bot.id).toEqual(wg1.id);\n                        done();\n                    })\n                        .catch(fail);\n                };\n                // Start joining\n                wg1.join();\n            });\n        });\n        describe('should send/receive', () => {\n            let called1;\n            beforeEach((done) => {\n                called1 = 0;\n                const queue = new Queue(3);\n                queue.wait().then(() => {\n                    cleanWebGroup(wg1);\n                    done();\n                });\n                wg1 = new WebGroup(WebGroupOptions);\n                wg1.onStateChange = (state) => {\n                    if (state === WebGroupState.JOINED) {\n                        queue.pop();\n                    }\n                };\n                wg1.onMemberJoin = () => queue.pop();\n                wg1.onSignalingStateChange = (state) => {\n                    if (state === SignalingState.STABLE) {\n                        // Start inviting\n                        wg1.invite(BOT_URL);\n                    }\n                };\n                waitBotJoin(wg1.id).then(() => queue.pop());\n                wg1.join();\n            });\n            afterEach((done) => {\n                cleanWebGroup(wg1);\n                if (wg1.state !== WebGroupState.LEFT) {\n                    wg1.onStateChange = (state) => {\n                        if (state === WebGroupState.LEFT) {\n                            cleanWebGroup(wg1);\n                            done();\n                        }\n                    };\n                    wg1.leave();\n                }\n                else {\n                    cleanWebGroup(wg1);\n                    done();\n                }\n            });\n            /** @test {WebGroup#send} */\n            it('broadcast String', (done) => {\n                const msg1 = 'sendArt is long, life is short';\n                const msgBot = 'bot: ' + msg1;\n                // Code for peer 1\n                wg1.onMessage = (id, msg) => {\n                    called1++;\n                    expect(msg).toEqual(msgBot);\n                    // Check bot data\n                    wait(1000)\n                        .then(() => getBotData(wg1.id))\n                        .then((bot) => {\n                        expect(called1).toEqual(1);\n                        expect(id).toEqual(bot.myId);\n                        expect(bot.onMessageToBeCalled).toEqual(1);\n                        expect(bot.messages[0].msg).toEqual(msg1);\n                        expect(bot.messages[0].id).toEqual(wg1.myId);\n                        done();\n                    })\n                        .catch(fail);\n                };\n                // Start sending message\n                wg1.send(msg1);\n            });\n            /** @test {WebGroup#send} */\n            it('broadcast ArrayBuffer', (done) => {\n                const msg1 = new Uint8Array([10, 34, 248, 157, 10, 8, 220]);\n                const msgBot = new Uint8Array([42, 34, 248, 157, 10, 8, 220]);\n                // Code for peer 1\n                wg1.onMessage = (id, msg) => {\n                    called1++;\n                    expect(msg).toEqual(msgBot);\n                    // Check bot data\n                    wait(1000)\n                        .then(() => getBotData(wg1.id))\n                        .then((bot) => {\n                        expect(called1).toEqual(1);\n                        expect(id).toEqual(bot.myId);\n                        expect(bot.onMessageToBeCalled).toEqual(1);\n                        expect(bot.messages[0].msg).toEqual(Array.from(msg1));\n                        expect(bot.messages[0].id).toEqual(wg1.myId);\n                        done();\n                    })\n                        .catch(fail);\n                };\n                // Start sending message\n                wg1.send(msg1);\n            });\n            /** @test {WebGroup#sendTo} */\n            it('private String', (done) => {\n                const msg1 = 'Art is long, life is short';\n                const msgBot = 'bot: ' + msg1;\n                // Code for peer 1\n                wg1.onMessage = (id, msg) => {\n                    called1++;\n                    expect(msg).toEqual(msgBot);\n                    // Check bot data\n                    wait(1000)\n                        .then(() => getBotData(wg1.id))\n                        .then((bot) => {\n                        expect(called1).toEqual(1);\n                        expect(id).toEqual(bot.myId);\n                        expect(bot.onMessageToBeCalled).toEqual(1);\n                        expect(bot.messages[0].msg).toEqual(msg1);\n                        expect(bot.messages[0].id).toEqual(wg1.myId);\n                        done();\n                    })\n                        .catch(fail);\n                };\n                // Start sending message\n                wg1.sendTo(wg1.members[1], msg1);\n            });\n            /** @test {WebGroup#sendTo} */\n            it('private ArrayBuffer', (done) => {\n                const msg1 = new Uint8Array([45, 34, 248, 157, 10, 8, 220]);\n                const msgBot = new Uint8Array([42, 34, 248, 157, 10, 8, 220]);\n                // Code for peer 1\n                wg1.onMessage = (id, msg) => {\n                    called1++;\n                    expect(msg).toEqual(msgBot);\n                    // Check bot data\n                    wait(1000)\n                        .then(() => getBotData(wg1.id))\n                        .then((bot) => {\n                        expect(called1).toEqual(1);\n                        expect(id).toEqual(bot.myId);\n                        expect(bot.onMessageToBeCalled).toEqual(1);\n                        expect(bot.messages[0].msg).toEqual(Array.from(msg1));\n                        expect(bot.messages[0].id).toEqual(wg1.myId);\n                        done();\n                    })\n                        .catch(fail);\n                };\n                // Start sending message\n                wg1.sendTo(wg1.members[1], msg1);\n            });\n        });\n        // TODO: finish these tests\n        xdescribe('leaving', () => { });\n    });\n});\n",
    "static": true,
    "longname": "/home/philippe/workspace/netflux/docs/jsFromTs/test/functional/2members.test.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 95,
    "kind": "test",
    "name": "describe14",
    "testId": 14,
    "memberof": "test/functional/2members.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14",
    "access": null,
    "description": "2 members",
    "lineNumber": 10,
    "testTargets": [
      "WebGroup"
    ]
  },
  {
    "__docId__": 96,
    "kind": "test",
    "name": "describe15",
    "testId": 15,
    "memberof": "test/functional/2members.test.js~describe14",
    "testDepth": 1,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe15",
    "access": null,
    "description": "🙂 🙂",
    "lineNumber": 11
  },
  {
    "__docId__": 97,
    "kind": "test",
    "name": "describe16",
    "testId": 16,
    "memberof": "test/functional/2members.test.js~describe14.describe15",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe15.describe16",
    "access": null,
    "description": "joining",
    "lineNumber": 14,
    "testTargets": [
      "WebGroup#join"
    ]
  },
  {
    "__docId__": 98,
    "kind": "test",
    "name": "it17",
    "testId": 17,
    "memberof": "test/functional/2members.test.js~describe14.describe15.describe16",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe15.describe16.it17",
    "access": null,
    "description": "should change the Signaling state",
    "lineNumber": 69,
    "testTargets": [
      "WebGroup#onSignalingStateChange"
    ]
  },
  {
    "__docId__": 99,
    "kind": "test",
    "name": "it18",
    "testId": 18,
    "memberof": "test/functional/2members.test.js~describe14.describe15.describe16",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe15.describe16.it18",
    "access": null,
    "description": "should change the WebGroup state",
    "lineNumber": 93,
    "testTargets": [
      "WebGroup#onStateChange"
    ]
  },
  {
    "__docId__": 100,
    "kind": "test",
    "name": "it19",
    "testId": 19,
    "memberof": "test/functional/2members.test.js~describe14.describe15.describe16",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe15.describe16.it19",
    "access": null,
    "description": "should be notified about new member",
    "lineNumber": 117,
    "testTargets": [
      "WebGroup#onMemberJoin"
    ]
  },
  {
    "__docId__": 101,
    "kind": "test",
    "name": "it20",
    "testId": 20,
    "memberof": "test/functional/2members.test.js~describe14.describe15.describe16",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe15.describe16.it20",
    "access": null,
    "description": "should have the same members, key, WebGroup id, topology once joined",
    "lineNumber": 145
  },
  {
    "__docId__": 102,
    "kind": "test",
    "name": "it21",
    "testId": 21,
    "memberof": "test/functional/2members.test.js~describe14.describe15.describe16",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe15.describe16.it21",
    "access": null,
    "description": "should join with the specified key",
    "lineNumber": 178,
    "testTargets": [
      "WebGroup#join"
    ]
  },
  {
    "__docId__": 103,
    "kind": "test",
    "name": "describe22",
    "testId": 22,
    "memberof": "test/functional/2members.test.js~describe14.describe15",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe15.describe22",
    "access": null,
    "description": "should send/receive",
    "lineNumber": 206
  },
  {
    "__docId__": 104,
    "kind": "test",
    "name": "it23",
    "testId": 23,
    "memberof": "test/functional/2members.test.js~describe14.describe15.describe22",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe15.describe22.it23",
    "access": null,
    "description": "broadcast String",
    "lineNumber": 266,
    "testTargets": [
      "WebGroup#send"
    ]
  },
  {
    "__docId__": 105,
    "kind": "test",
    "name": "it24",
    "testId": 24,
    "memberof": "test/functional/2members.test.js~describe14.describe15.describe22",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe15.describe22.it24",
    "access": null,
    "description": "broadcast ArrayBuffer",
    "lineNumber": 291,
    "testTargets": [
      "WebGroup#send"
    ]
  },
  {
    "__docId__": 106,
    "kind": "test",
    "name": "it25",
    "testId": 25,
    "memberof": "test/functional/2members.test.js~describe14.describe15.describe22",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe15.describe22.it25",
    "access": null,
    "description": "private String",
    "lineNumber": 318,
    "testTargets": [
      "WebGroup#sendTo"
    ]
  },
  {
    "__docId__": 107,
    "kind": "test",
    "name": "it26",
    "testId": 26,
    "memberof": "test/functional/2members.test.js~describe14.describe15.describe22",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe15.describe22.it26",
    "access": null,
    "description": "private ArrayBuffer",
    "lineNumber": 343,
    "testTargets": [
      "WebGroup#sendTo"
    ]
  },
  {
    "__docId__": 108,
    "kind": "test",
    "name": "describe27",
    "testId": 27,
    "memberof": "test/functional/2members.test.js~describe14.describe15",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe15.describe27",
    "access": null,
    "description": "leaving",
    "lineNumber": 370
  },
  {
    "__docId__": 109,
    "kind": "test",
    "name": "it28",
    "testId": 28,
    "memberof": "test/functional/2members.test.js~describe14.describe15.describe27",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe15.describe27.it28",
    "access": null,
    "description": "should have no members & an empty key",
    "lineNumber": 430,
    "testTargets": [
      "WebGroup#leave"
    ]
  },
  {
    "__docId__": 110,
    "kind": "test",
    "name": "it29",
    "testId": 29,
    "memberof": "test/functional/2members.test.js~describe14.describe15.describe27",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe15.describe27.it29",
    "access": null,
    "description": "should be notified about left member",
    "lineNumber": 464,
    "testTargets": [
      "WebGroup#onMemberLeave"
    ]
  },
  {
    "__docId__": 111,
    "kind": "test",
    "name": "it30",
    "testId": 30,
    "memberof": "test/functional/2members.test.js~describe14.describe15.describe27",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe15.describe27.it30",
    "access": null,
    "description": "should change the WebGroup state",
    "lineNumber": 489,
    "testTargets": [
      "WebGroup#onStateChange"
    ]
  },
  {
    "__docId__": 112,
    "kind": "test",
    "name": "it31",
    "testId": 31,
    "memberof": "test/functional/2members.test.js~describe14.describe15.describe27",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe15.describe27.it31",
    "access": null,
    "description": "should change the Signaling state",
    "lineNumber": 508,
    "testTargets": [
      "WebGroup#onSignalingStateChange"
    ]
  },
  {
    "__docId__": 113,
    "kind": "test",
    "name": "describe32",
    "testId": 32,
    "memberof": "test/functional/2members.test.js~describe14",
    "testDepth": 1,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe32",
    "access": null,
    "description": "🙂 🤖",
    "lineNumber": 528
  },
  {
    "__docId__": 114,
    "kind": "test",
    "name": "describe33",
    "testId": 33,
    "memberof": "test/functional/2members.test.js~describe14.describe32",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe32.describe33",
    "access": null,
    "description": "inviting",
    "lineNumber": 531,
    "testTargets": [
      "WebGroup#invite"
    ]
  },
  {
    "__docId__": 115,
    "kind": "test",
    "name": "it34",
    "testId": 34,
    "memberof": "test/functional/2members.test.js~describe14.describe32.describe33",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe32.describe33.it34",
    "access": null,
    "description": "should not change the Signaling state",
    "lineNumber": 550,
    "testTargets": [
      "WebGroup#onSignalingStateChange"
    ]
  },
  {
    "__docId__": 116,
    "kind": "test",
    "name": "it35",
    "testId": 35,
    "memberof": "test/functional/2members.test.js~describe14.describe32.describe33",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe32.describe33.it35",
    "access": null,
    "description": "should change the WebGroup state",
    "lineNumber": 571,
    "testTargets": [
      "WebGroup#onStateChange"
    ]
  },
  {
    "__docId__": 117,
    "kind": "test",
    "name": "it36",
    "testId": 36,
    "memberof": "test/functional/2members.test.js~describe14.describe32.describe33",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe32.describe33.it36",
    "access": null,
    "description": "should be notified about new member",
    "lineNumber": 592,
    "testTargets": [
      "WebGroup#onMemberJoin"
    ]
  },
  {
    "__docId__": 118,
    "kind": "test",
    "name": "it37",
    "testId": 37,
    "memberof": "test/functional/2members.test.js~describe14.describe32.describe33",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe32.describe33.it37",
    "access": null,
    "description": "should have the same members, WebGroup id, topology once joined",
    "lineNumber": 620
  },
  {
    "__docId__": 119,
    "kind": "test",
    "name": "describe38",
    "testId": 38,
    "memberof": "test/functional/2members.test.js~describe14.describe32",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe32.describe38",
    "access": null,
    "description": "should send/receive",
    "lineNumber": 646
  },
  {
    "__docId__": 120,
    "kind": "test",
    "name": "it39",
    "testId": 39,
    "memberof": "test/functional/2members.test.js~describe14.describe32.describe38",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe32.describe38.it39",
    "access": null,
    "description": "broadcast String",
    "lineNumber": 688,
    "testTargets": [
      "WebGroup#send"
    ]
  },
  {
    "__docId__": 121,
    "kind": "test",
    "name": "it40",
    "testId": 40,
    "memberof": "test/functional/2members.test.js~describe14.describe32.describe38",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe32.describe38.it40",
    "access": null,
    "description": "broadcast ArrayBuffer",
    "lineNumber": 712,
    "testTargets": [
      "WebGroup#send"
    ]
  },
  {
    "__docId__": 122,
    "kind": "test",
    "name": "it41",
    "testId": 41,
    "memberof": "test/functional/2members.test.js~describe14.describe32.describe38",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe32.describe38.it41",
    "access": null,
    "description": "private String",
    "lineNumber": 736,
    "testTargets": [
      "WebGroup#sendTo"
    ]
  },
  {
    "__docId__": 123,
    "kind": "test",
    "name": "it42",
    "testId": 42,
    "memberof": "test/functional/2members.test.js~describe14.describe32.describe38",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/2members.test.js~describe14.describe32.describe38.it42",
    "access": null,
    "description": "private ArrayBuffer",
    "lineNumber": 760,
    "testTargets": [
      "WebGroup#sendTo"
    ]
  },
  {
    "__docId__": 124,
    "kind": "testFile",
    "name": "test/functional/3members.test.js",
    "content": "/// <reference types='jasmine' />\n/* tslint:disable:one-variable-per-declaration */\nimport { SignalingState, WebGroup, WebGroupState } from '../../src/index.browser';\nimport { areTheSame, cleanWebGroup, Queue, SIGNALING_URL, wait } from '../util/helper';\nconst WebGroupOptions = {\n    signalingServer: SIGNALING_URL,\n    autoRejoin: false,\n};\n/** @test {WebGroup} */\ndescribe('3 members', () => {\n    describe('🙂 🙂 🙂', () => {\n        let wg1, wg2, wg3;\n        let called1, called2, called3;\n        /** @test {WebGroup#join} */\n        describe('joining', () => {\n            beforeEach((done) => {\n                called1 = 0;\n                called2 = 0;\n                called3 = 0;\n                const queue = new Queue(4);\n                queue.wait().then(() => {\n                    cleanWebGroup(wg1);\n                    cleanWebGroup(wg2);\n                    cleanWebGroup(wg3);\n                    done();\n                });\n                wg1 = new WebGroup(WebGroupOptions);\n                wg2 = new WebGroup(WebGroupOptions);\n                wg3 = new WebGroup(WebGroupOptions);\n                wg1.onSignalingStateChange = (state) => {\n                    if (state === SignalingState.STABLE) {\n                        wg2.join(wg1.key);\n                    }\n                };\n                wg1.onMemberJoin = () => queue.pop();\n                wg2.onStateChange = (state) => {\n                    if (state === WebGroupState.JOINED) {\n                        queue.pop();\n                    }\n                };\n                wg2.onSignalingStateChange = (state) => {\n                    if (state === SignalingState.STABLE) {\n                        queue.pop();\n                    }\n                };\n                wg2.onMemberJoin = () => queue.pop();\n                wg1.join();\n            });\n            afterEach((done) => {\n                cleanWebGroup(wg1);\n                cleanWebGroup(wg2);\n                cleanWebGroup(wg3);\n                const queue = new Queue(3);\n                if (wg1.state !== WebGroupState.LEFT) {\n                    wg1.onStateChange = (state) => {\n                        if (state === WebGroupState.LEFT) {\n                            queue.pop();\n                        }\n                    };\n                    wg1.leave();\n                }\n                else {\n                    queue.pop();\n                }\n                if (wg2.state !== WebGroupState.LEFT) {\n                    wg2.onStateChange = (state) => {\n                        if (state === WebGroupState.LEFT) {\n                            queue.pop();\n                        }\n                    };\n                    wg2.leave();\n                }\n                else {\n                    queue.pop();\n                }\n                if (wg3.state !== WebGroupState.LEFT) {\n                    wg3.onStateChange = (state) => {\n                        if (state === WebGroupState.LEFT) {\n                            queue.pop();\n                        }\n                    };\n                    wg3.leave();\n                }\n                else {\n                    queue.pop();\n                }\n                queue.wait().then(() => {\n                    cleanWebGroup(wg1);\n                    cleanWebGroup(wg2);\n                    cleanWebGroup(wg3);\n                    done();\n                });\n            });\n            /** @test {WebGroup#onSignalingStateChange} */\n            it('should change the Signaling state', (done) => {\n                const states = [];\n                const expectedStates = [SignalingState.CONNECTING, SignalingState.CONNECTED, SignalingState.STABLE];\n                // Code for peer 1\n                wg1.onSignalingStateChange = () => called1++;\n                // Code for peer 2\n                wg2.onSignalingStateChange = () => called2++;\n                // Code for peer 3\n                wg3.onSignalingStateChange = (state) => {\n                    states.push(state);\n                    called3++;\n                    if (state === SignalingState.STABLE) {\n                        wait(1000).then(() => {\n                            expect(called1).toEqual(0);\n                            expect(called2).toEqual(0);\n                            expect(called3).toEqual(3);\n                            expect(states).toEqual(expectedStates);\n                            expect(wg3.signalingState).toEqual(SignalingState.STABLE);\n                            done();\n                        });\n                    }\n                };\n                // Start joining\n                wg3.join(wg1.key);\n            });\n            /** @test {WebGroup#onStateChange} */\n            it('should change the WebGroup state', (done) => {\n                const states = [];\n                const expectedStates = [WebGroupState.JOINING, WebGroupState.JOINED];\n                // Code for peer 1\n                wg1.onStateChange = () => called1++;\n                // Code for peer 2\n                wg2.onStateChange = () => called2++;\n                // Code for peer 3\n                wg3.onStateChange = (state) => {\n                    states.push(state);\n                    called3++;\n                    if (state === WebGroupState.JOINED) {\n                        wait(1000).then(() => {\n                            expect(called1).toEqual(0);\n                            expect(called2).toEqual(0);\n                            expect(called3).toEqual(2);\n                            expect(states).toEqual(expectedStates);\n                            expect(wg3.state).toEqual(WebGroupState.JOINED);\n                            done();\n                        });\n                    }\n                };\n                // Start joining\n                wg3.join(wg1.key);\n            });\n            /** @test {WebGroup#onMemberJoin} */\n            it('should be notified about new member', (done) => {\n                const members3 = [];\n                const expectedMembers3 = [wg1.myId, wg2.myId];\n                const queue = new Queue(3);\n                queue.wait()\n                    .then(() => wait(1000))\n                    .then(() => {\n                    expect(called1).toEqual(1);\n                    expect(called2).toEqual(1);\n                    expect(called3).toEqual(2);\n                    expect(areTheSame(members3, expectedMembers3)).toBeTruthy();\n                    done();\n                });\n                // Code for peer 1\n                wg1.onMemberJoin = (id) => {\n                    expect(id).toEqual(wg3.myId);\n                    called1++;\n                    queue.pop();\n                };\n                // Code for peer 2\n                wg2.onMemberJoin = (id) => {\n                    expect(id).toEqual(wg3.myId);\n                    called2++;\n                    queue.pop();\n                };\n                // Code for peer 3\n                wg3.onMemberJoin = (id) => {\n                    members3.push(id);\n                    called3++;\n                    if (called3 === 2) {\n                        queue.pop();\n                    }\n                };\n                // Start joining\n                wg3.join(wg1.key);\n            });\n            it('should have the same members, key, WebGroup id, topology once joined', (done) => {\n                const queue = new Queue(3);\n                queue.wait()\n                    .then(() => wait(1000))\n                    .then(() => {\n                    expect(areTheSame(wg3.members, wg1.members)).toBeTruthy();\n                    expect(areTheSame(wg3.members, wg2.members)).toBeTruthy();\n                    expect(wg3.id).toEqual(wg1.id);\n                    expect(wg3.key).toEqual(wg1.key);\n                    expect(wg3.topology).toEqual(wg1.topology);\n                    done();\n                });\n                // Code for peer 1\n                wg1.onMemberJoin = () => queue.pop();\n                // Code for peer 2\n                wg2.onMemberJoin = () => queue.pop();\n                // Code for peer 3\n                wg3.onStateChange = (state) => {\n                    if (state === WebGroupState.JOINED) {\n                        expect(wg3.members.length).toEqual(3);\n                        expect(wg3.members.includes(wg1.myId)).toBeTruthy();\n                        expect(wg3.members.includes(wg2.myId)).toBeTruthy();\n                        expect(wg3.members.includes(wg3.myId)).toBeTruthy();\n                        expect(wg3.id).toEqual(wg1.id);\n                        expect(wg3.key).toEqual(wg1.key);\n                        expect(wg3.topology).toEqual(wg1.topology);\n                        queue.pop();\n                    }\n                };\n                // Start joining\n                wg3.join(wg1.key);\n            });\n        });\n        describe('should send/receive', () => {\n            beforeEach((done) => {\n                called1 = 0;\n                called2 = 0;\n                called3 = 0;\n                const queue = new Queue(9);\n                wg1 = new WebGroup(WebGroupOptions);\n                wg2 = new WebGroup(WebGroupOptions);\n                wg3 = new WebGroup(WebGroupOptions);\n                wg1.onSignalingStateChange = (state) => {\n                    if (state === SignalingState.STABLE) {\n                        wg2.join(wg1.key);\n                    }\n                };\n                wg1.onMemberJoin = () => queue.pop();\n                wg1.onStateChange = (state) => {\n                    if (state === WebGroupState.JOINED) {\n                        queue.pop();\n                    }\n                };\n                wg2.onStateChange = (state) => {\n                    if (state === WebGroupState.JOINED) {\n                        queue.pop();\n                    }\n                };\n                wg2.onSignalingStateChange = (state) => {\n                    if (state === SignalingState.STABLE) {\n                        wg3.join(wg1.key);\n                    }\n                };\n                wg2.onMemberJoin = () => queue.pop();\n                wg3.onStateChange = (state) => {\n                    if (state === WebGroupState.JOINED) {\n                        queue.pop();\n                    }\n                };\n                wg3.onMemberJoin = () => queue.pop();\n                wg1.join();\n                queue.wait().then(() => {\n                    cleanWebGroup(wg1);\n                    cleanWebGroup(wg2);\n                    cleanWebGroup(wg3);\n                    done();\n                });\n            });\n            afterEach((done) => {\n                cleanWebGroup(wg1);\n                cleanWebGroup(wg2);\n                cleanWebGroup(wg3);\n                const queue = new Queue(3);\n                if (wg1.state !== WebGroupState.LEFT) {\n                    wg1.onStateChange = (state) => {\n                        if (state === WebGroupState.LEFT) {\n                            queue.pop();\n                        }\n                    };\n                    wg1.leave();\n                }\n                else {\n                    queue.pop();\n                }\n                if (wg2.state !== WebGroupState.LEFT) {\n                    wg2.onStateChange = (state) => {\n                        if (state === WebGroupState.LEFT) {\n                            queue.pop();\n                        }\n                    };\n                    wg2.leave();\n                }\n                else {\n                    queue.pop();\n                }\n                if (wg3.state !== WebGroupState.LEFT) {\n                    wg3.onStateChange = (state) => {\n                        if (state === WebGroupState.LEFT) {\n                            queue.pop();\n                        }\n                    };\n                    wg3.leave();\n                }\n                else {\n                    queue.pop();\n                }\n                queue.wait().then(() => {\n                    cleanWebGroup(wg1);\n                    cleanWebGroup(wg2);\n                    cleanWebGroup(wg3);\n                    done();\n                });\n            });\n            /** @test {WebGroup#send} */\n            it('broadcast String', (done) => {\n                const queue = new Queue(6);\n                queue.wait()\n                    .then(() => wait(1000))\n                    .then(() => {\n                    expect(called1).toEqual(2);\n                    expect(called2).toEqual(2);\n                    expect(called3).toEqual(2);\n                    expect(areTheSame(messages1.ids, [wg2.myId, wg3.myId])).toBeTruthy();\n                    expect(areTheSame(messages1.msgs, [msg2, msg3])).toBeTruthy();\n                    expect(areTheSame(messages2.ids, [wg1.myId, wg3.myId])).toBeTruthy();\n                    expect(areTheSame(messages2.msgs, [msg1, msg3])).toBeTruthy();\n                    expect(areTheSame(messages3.ids, [wg2.myId, wg1.myId])).toBeTruthy();\n                    expect(areTheSame(messages3.msgs, [msg2, msg1])).toBeTruthy();\n                    done();\n                });\n                const msg1 = 'Art is long, life is short';\n                const msg2 = 'Do or do not, there is no try';\n                const msg3 = 'Never say never';\n                const messages1 = { ids: [], msgs: [] };\n                const messages2 = { ids: [], msgs: [] };\n                const messages3 = { ids: [], msgs: [] };\n                // Code for peer 1\n                wg1.onMessage = (id, msg) => {\n                    messages1.ids.push(id);\n                    messages1.msgs.push(msg);\n                    called1++;\n                    queue.pop();\n                };\n                // Code for peer 2\n                wg2.onMessage = (id, msg) => {\n                    messages2.ids.push(id);\n                    messages2.msgs.push(msg);\n                    called2++;\n                    queue.pop();\n                };\n                // Code for peer 3\n                wg3.onMessage = (id, msg) => {\n                    messages3.ids.push(id);\n                    messages3.msgs.push(msg);\n                    called3++;\n                    queue.pop();\n                };\n                // Start sending message\n                wg1.send(msg1);\n                wg2.send(msg2);\n                wg3.send(msg3);\n            });\n            /** @test {WebGroup#send} */\n            it('broadcast ArrayBuffer', (done) => {\n                const queue = new Queue(6);\n                queue.wait()\n                    .then(() => wait(1000))\n                    .then(() => {\n                    expect(called1).toEqual(2);\n                    expect(called2).toEqual(2);\n                    expect(called3).toEqual(2);\n                    expect(areTheSame(messages1.ids, [wg2.myId, wg3.myId])).toBeTruthy();\n                    expect(areTheSame(messages1.msgs, [msg2, msg3])).toBeTruthy();\n                    expect(areTheSame(messages2.ids, [wg1.myId, wg3.myId])).toBeTruthy();\n                    expect(areTheSame(messages2.msgs, [msg1, msg3])).toBeTruthy();\n                    expect(areTheSame(messages3.ids, [wg2.myId, wg1.myId])).toBeTruthy();\n                    expect(areTheSame(messages3.msgs, [msg2, msg1])).toBeTruthy();\n                    done();\n                });\n                const msg1 = new Uint8Array([42, 347, 248247, 583, 10, 8, 9623]);\n                const msg2 = new Uint8Array([845, 4, 798240, 3290, 553, 1, 398539857, 84]);\n                const msg3 = new Uint8Array([84, 79, 240, 30, 53, 3, 339857, 44]);\n                const messages1 = { ids: [], msgs: [] };\n                const messages2 = { ids: [], msgs: [] };\n                const messages3 = { ids: [], msgs: [] };\n                // Code for peer 1\n                wg1.onMessage = (id, msg) => {\n                    expect(msg instanceof Uint8Array).toBeTruthy();\n                    messages1.ids.push(id);\n                    messages1.msgs.push(msg);\n                    called1++;\n                    queue.pop();\n                };\n                // Code for peer 2\n                wg2.onMessage = (id, msg) => {\n                    expect(msg instanceof Uint8Array).toBeTruthy();\n                    messages2.ids.push(id);\n                    messages2.msgs.push(msg);\n                    called2++;\n                    queue.pop();\n                };\n                // Code for peer 3\n                wg3.onMessage = (id, msg) => {\n                    expect(msg instanceof Uint8Array).toBeTruthy();\n                    messages3.ids.push(id);\n                    messages3.msgs.push(msg);\n                    called3++;\n                    queue.pop();\n                };\n                // Start sending message\n                wg1.send(msg1);\n                wg2.send(msg2);\n                wg3.send(msg3);\n            });\n            /** @test {WebGroup#sendTo} */\n            it('private String', (done) => {\n                const queue = new Queue(6);\n                queue.wait()\n                    .then(() => wait(1000))\n                    .then(() => {\n                    expect(called1).toEqual(2);\n                    expect(called2).toEqual(2);\n                    expect(called3).toEqual(2);\n                    expect(areTheSame(messages1.ids, [wg2.myId, wg3.myId])).toBeTruthy();\n                    expect(areTheSame(messages1.msgs, [msg2For1, msg3For1])).toBeTruthy();\n                    expect(areTheSame(messages2.ids, [wg1.myId, wg3.myId])).toBeTruthy();\n                    expect(areTheSame(messages2.msgs, [msg1For2, msg3For2])).toBeTruthy();\n                    expect(areTheSame(messages3.ids, [wg2.myId, wg1.myId])).toBeTruthy();\n                    expect(areTheSame(messages3.msgs, [msg2For3, msg1For3])).toBeTruthy();\n                    done();\n                });\n                const msg1For2 = 'Art is long, life is short2';\n                const msg1For3 = 'Art is long, life is short3';\n                const msg2For1 = 'Do or do not, there is no try1';\n                const msg2For3 = 'Do or do not, there is no try3';\n                const msg3For1 = 'Never say never1';\n                const msg3For2 = 'Never say never2';\n                const messages1 = { ids: [], msgs: [] };\n                const messages2 = { ids: [], msgs: [] };\n                const messages3 = { ids: [], msgs: [] };\n                // Code for peer 1\n                wg1.onMessage = (id, msg) => {\n                    messages1.ids.push(id);\n                    messages1.msgs.push(msg);\n                    called1++;\n                    queue.pop();\n                };\n                // Code for peer 2\n                wg2.onMessage = (id, msg) => {\n                    messages2.ids.push(id);\n                    messages2.msgs.push(msg);\n                    called2++;\n                    queue.pop();\n                };\n                // Code for peer 3\n                wg3.onMessage = (id, msg) => {\n                    messages3.ids.push(id);\n                    messages3.msgs.push(msg);\n                    called3++;\n                    queue.pop();\n                };\n                // Start sending message\n                wg1.sendTo(wg2.myId, msg1For2);\n                wg1.sendTo(wg3.myId, msg1For3);\n                wg2.sendTo(wg1.myId, msg2For1);\n                wg2.sendTo(wg3.myId, msg2For3);\n                wg3.sendTo(wg1.myId, msg3For1);\n                wg3.sendTo(wg2.myId, msg3For2);\n            });\n            /** @test {WebGroup#sendTo} */\n            it('private ArrayBuffer', (done) => {\n                const queue = new Queue(6);\n                queue.wait()\n                    .then(() => wait(1000))\n                    .then(() => {\n                    expect(called1).toEqual(2);\n                    expect(called2).toEqual(2);\n                    expect(called3).toEqual(2);\n                    expect(areTheSame(messages1.ids, [wg2.myId, wg3.myId])).toBeTruthy();\n                    expect(areTheSame(messages1.msgs, [msg2For1, msg3For1])).toBeTruthy();\n                    expect(areTheSame(messages2.ids, [wg1.myId, wg3.myId])).toBeTruthy();\n                    expect(areTheSame(messages2.msgs, [msg1For2, msg3For2])).toBeTruthy();\n                    expect(areTheSame(messages3.ids, [wg2.myId, wg1.myId])).toBeTruthy();\n                    expect(areTheSame(messages3.msgs, [msg2For3, msg1For3])).toBeTruthy();\n                    done();\n                });\n                const msg1For2 = new Uint8Array([42, 347, 248247, 583, 10, 8, 2]);\n                const msg1For3 = new Uint8Array([42, 347, 248247, 583, 10, 8, 3]);\n                const msg2For1 = new Uint8Array([845, 4, 798240, 3290, 553, 1, 398539857, 1]);\n                const msg2For3 = new Uint8Array([845, 4, 798240, 3290, 553, 1, 398539857, 3]);\n                const msg3For1 = new Uint8Array([84, 79, 240, 30, 53, 3, 339857, 1]);\n                const msg3For2 = new Uint8Array([84, 79, 240, 30, 53, 3, 339857, 2]);\n                const messages1 = { ids: [], msgs: [] };\n                const messages2 = { ids: [], msgs: [] };\n                const messages3 = { ids: [], msgs: [] };\n                // Code for peer 1\n                wg1.onMessage = (id, msg) => {\n                    expect(msg instanceof Uint8Array).toBeTruthy();\n                    messages1.ids.push(id);\n                    messages1.msgs.push(msg);\n                    called1++;\n                    queue.pop();\n                };\n                // Code for peer 2\n                wg2.onMessage = (id, msg) => {\n                    expect(msg instanceof Uint8Array).toBeTruthy();\n                    messages2.ids.push(id);\n                    messages2.msgs.push(msg);\n                    called2++;\n                    queue.pop();\n                };\n                // Code for peer 3\n                wg3.onMessage = (id, msg) => {\n                    expect(msg instanceof Uint8Array).toBeTruthy();\n                    messages3.ids.push(id);\n                    messages3.msgs.push(msg);\n                    called3++;\n                    queue.pop();\n                };\n                // Start sending message\n                wg1.sendTo(wg2.myId, msg1For2);\n                wg1.sendTo(wg3.myId, msg1For3);\n                wg2.sendTo(wg1.myId, msg2For1);\n                wg2.sendTo(wg3.myId, msg2For3);\n                wg3.sendTo(wg1.myId, msg3For1);\n                wg3.sendTo(wg2.myId, msg3For2);\n            });\n        });\n        // TODO: finish test\n        xdescribe('leaving', () => {\n            beforeEach((done) => {\n                called1 = 0;\n                called2 = 0;\n                called3 = 0;\n                const queue = new Queue(4);\n                queue.wait().then(() => {\n                    cleanWebGroup(wg1);\n                    cleanWebGroup(wg2);\n                    cleanWebGroup(wg3);\n                    done();\n                });\n                wg1 = new WebGroup(WebGroupOptions);\n                wg2 = new WebGroup(WebGroupOptions);\n                wg3 = new WebGroup(WebGroupOptions);\n                wg1.onSignalingStateChange = (state) => {\n                    if (state === SignalingState.STABLE) {\n                        wg2.join(wg1.key);\n                    }\n                };\n                wg1.onMemberJoin = () => queue.pop();\n                wg2.onStateChange = (state) => {\n                    if (state === WebGroupState.JOINED) {\n                        queue.pop();\n                    }\n                };\n                wg2.onSignalingStateChange = (state) => {\n                    if (state === SignalingState.STABLE) {\n                        queue.pop();\n                    }\n                };\n                wg2.onMemberJoin = () => queue.pop();\n                wg1.join();\n            });\n            afterEach((done) => {\n                cleanWebGroup(wg1);\n                cleanWebGroup(wg2);\n                cleanWebGroup(wg3);\n                const queue = new Queue(3);\n                if (wg1.state !== WebGroupState.LEFT) {\n                    wg1.onStateChange = (state) => {\n                        if (state === WebGroupState.LEFT) {\n                            queue.pop();\n                        }\n                    };\n                    wg1.leave();\n                }\n                else {\n                    queue.pop();\n                }\n                if (wg2.state !== WebGroupState.LEFT) {\n                    wg2.onStateChange = (state) => {\n                        if (state === WebGroupState.LEFT) {\n                            queue.pop();\n                        }\n                    };\n                    wg2.leave();\n                }\n                else {\n                    queue.pop();\n                }\n                if (wg3.state !== WebGroupState.LEFT) {\n                    wg3.onStateChange = (state) => {\n                        if (state === WebGroupState.LEFT) {\n                            queue.pop();\n                        }\n                    };\n                    wg3.leave();\n                }\n                else {\n                    queue.pop();\n                }\n                queue.wait().then(() => {\n                    cleanWebGroup(wg1);\n                    cleanWebGroup(wg2);\n                    cleanWebGroup(wg3);\n                    done();\n                });\n            });\n            /** @test {WebGroup#leave} */\n            it('should have no members & an empty key', (done) => {\n                const queue = new Queue(1);\n                // Code for peer 1\n                wg1.onMemberLeave = () => {\n                    expect(wg1.members.length).toEqual(1);\n                    expect(wg1.members.includes(wg1.myId)).toBeTruthy();\n                    queue.pop();\n                };\n                // Code for peer 2\n                wg2.onStateChange = (state) => {\n                    if (state === WebGroupState.LEFT) {\n                        called2++;\n                        expect(wg2.members.length).toEqual(1);\n                        expect(wg2.members.includes(wg2.myId)).toBeTruthy();\n                        expect(wg2.key).toEqual('');\n                        queue.wait()\n                            .then(() => wait(1000))\n                            .then(() => {\n                            expect(wg1.members.length).toEqual(1);\n                            expect(wg1.members.includes(wg1.myId)).toBeTruthy();\n                            expect(wg2.members.length).toEqual(1);\n                            expect(wg2.members.includes(wg2.myId)).toBeTruthy();\n                            expect(wg2.key).toEqual('');\n                            expect(called2).toEqual(1);\n                            expect(wg2.key).toEqual('');\n                            done();\n                        });\n                    }\n                };\n                // Start leaving\n                wg2.leave();\n            });\n            /** @test {WebGroup#onMemberLeave} */\n            it('should be notified about left member', (done) => {\n                const queue = new Queue(2);\n                // Code for peer 1\n                wg1.onMemberLeave = (id) => {\n                    expect(id).toEqual(wg2.myId);\n                    called1++;\n                    queue.pop();\n                };\n                // Code for peer 2\n                wg2.onMemberLeave = (id) => {\n                    expect(id).toEqual(wg1.myId);\n                    called2++;\n                    queue.pop();\n                };\n                // Start leaving\n                wg2.leave();\n                // When finish test\n                queue.wait().then(() => {\n                    wait(1000).then(() => {\n                        expect(called1).toEqual(1);\n                        expect(called2).toEqual(1);\n                        done();\n                    });\n                });\n            });\n            /** @test {WebGroup#onStateChange} */\n            it('should change the WebGroup state', (done) => {\n                // Code for peer 2\n                wg2.onStateChange = (state) => {\n                    if (state === WebGroupState.LEFT) {\n                        called2++;\n                    }\n                    wait(1000).then(() => {\n                        expect(called2).toEqual(1);\n                        expect(wg2.state).toEqual(WebGroupState.LEFT);\n                        done();\n                    });\n                };\n                // Start leaving\n                wg2.leave();\n            });\n            /** @test {WebGroup#onSignalingStateChange} */\n            it('should change the Signaling state', (done) => {\n                // Code for peer 2\n                wg2.onSignalingStateChange = (state) => {\n                    if (state === SignalingState.CLOSED) {\n                        called2++;\n                    }\n                    wait(1000).then(() => {\n                        expect(called2).toEqual(1);\n                        expect(wg2.signalingState).toEqual(SignalingState.CLOSED);\n                        done();\n                    });\n                };\n                // Start leaving\n                wg2.leave();\n            });\n        });\n    });\n});\n",
    "static": true,
    "longname": "/home/philippe/workspace/netflux/docs/jsFromTs/test/functional/3members.test.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 125,
    "kind": "test",
    "name": "describe43",
    "testId": 43,
    "memberof": "test/functional/3members.test.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/functional/3members.test.js~describe43",
    "access": null,
    "description": "3 members",
    "lineNumber": 10,
    "testTargets": [
      "WebGroup"
    ]
  },
  {
    "__docId__": 126,
    "kind": "test",
    "name": "describe44",
    "testId": 44,
    "memberof": "test/functional/3members.test.js~describe43",
    "testDepth": 1,
    "static": true,
    "longname": "test/functional/3members.test.js~describe43.describe44",
    "access": null,
    "description": "🙂 🙂 🙂",
    "lineNumber": 11
  },
  {
    "__docId__": 127,
    "kind": "test",
    "name": "describe45",
    "testId": 45,
    "memberof": "test/functional/3members.test.js~describe43.describe44",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/3members.test.js~describe43.describe44.describe45",
    "access": null,
    "description": "joining",
    "lineNumber": 15,
    "testTargets": [
      "WebGroup#join"
    ]
  },
  {
    "__docId__": 128,
    "kind": "test",
    "name": "it46",
    "testId": 46,
    "memberof": "test/functional/3members.test.js~describe43.describe44.describe45",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/3members.test.js~describe43.describe44.describe45.it46",
    "access": null,
    "description": "should change the Signaling state",
    "lineNumber": 95,
    "testTargets": [
      "WebGroup#onSignalingStateChange"
    ]
  },
  {
    "__docId__": 129,
    "kind": "test",
    "name": "it47",
    "testId": 47,
    "memberof": "test/functional/3members.test.js~describe43.describe44.describe45",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/3members.test.js~describe43.describe44.describe45.it47",
    "access": null,
    "description": "should change the WebGroup state",
    "lineNumber": 121,
    "testTargets": [
      "WebGroup#onStateChange"
    ]
  },
  {
    "__docId__": 130,
    "kind": "test",
    "name": "it48",
    "testId": 48,
    "memberof": "test/functional/3members.test.js~describe43.describe44.describe45",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/3members.test.js~describe43.describe44.describe45.it48",
    "access": null,
    "description": "should be notified about new member",
    "lineNumber": 147,
    "testTargets": [
      "WebGroup#onMemberJoin"
    ]
  },
  {
    "__docId__": 131,
    "kind": "test",
    "name": "it49",
    "testId": 49,
    "memberof": "test/functional/3members.test.js~describe43.describe44.describe45",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/3members.test.js~describe43.describe44.describe45.it49",
    "access": null,
    "description": "should have the same members, key, WebGroup id, topology once joined",
    "lineNumber": 183
  },
  {
    "__docId__": 132,
    "kind": "test",
    "name": "describe50",
    "testId": 50,
    "memberof": "test/functional/3members.test.js~describe43.describe44",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/3members.test.js~describe43.describe44.describe50",
    "access": null,
    "description": "should send/receive",
    "lineNumber": 216
  },
  {
    "__docId__": 133,
    "kind": "test",
    "name": "it51",
    "testId": 51,
    "memberof": "test/functional/3members.test.js~describe43.describe44.describe50",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/3members.test.js~describe43.describe44.describe50.it51",
    "access": null,
    "description": "broadcast String",
    "lineNumber": 307,
    "testTargets": [
      "WebGroup#send"
    ]
  },
  {
    "__docId__": 134,
    "kind": "test",
    "name": "it52",
    "testId": 52,
    "memberof": "test/functional/3members.test.js~describe43.describe44.describe50",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/3members.test.js~describe43.describe44.describe50.it52",
    "access": null,
    "description": "broadcast ArrayBuffer",
    "lineNumber": 356,
    "testTargets": [
      "WebGroup#send"
    ]
  },
  {
    "__docId__": 135,
    "kind": "test",
    "name": "it53",
    "testId": 53,
    "memberof": "test/functional/3members.test.js~describe43.describe44.describe50",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/3members.test.js~describe43.describe44.describe50.it53",
    "access": null,
    "description": "private String",
    "lineNumber": 408,
    "testTargets": [
      "WebGroup#sendTo"
    ]
  },
  {
    "__docId__": 136,
    "kind": "test",
    "name": "it54",
    "testId": 54,
    "memberof": "test/functional/3members.test.js~describe43.describe44.describe50",
    "testDepth": 3,
    "static": true,
    "longname": "test/functional/3members.test.js~describe43.describe44.describe50.it54",
    "access": null,
    "description": "private ArrayBuffer",
    "lineNumber": 463,
    "testTargets": [
      "WebGroup#sendTo"
    ]
  },
  {
    "__docId__": 137,
    "kind": "test",
    "name": "it55",
    "testId": 55,
    "memberof": "test/functional/3members.test.js~describe43.describe44",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/3members.test.js~describe43.describe44.it55",
    "access": null,
    "description": "should have no members & an empty key",
    "lineNumber": 602,
    "testTargets": [
      "WebGroup#leave"
    ]
  },
  {
    "__docId__": 138,
    "kind": "test",
    "name": "it56",
    "testId": 56,
    "memberof": "test/functional/3members.test.js~describe43.describe44",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/3members.test.js~describe43.describe44.it56",
    "access": null,
    "description": "should be notified about left member",
    "lineNumber": 635,
    "testTargets": [
      "WebGroup#onMemberLeave"
    ]
  },
  {
    "__docId__": 139,
    "kind": "test",
    "name": "it57",
    "testId": 57,
    "memberof": "test/functional/3members.test.js~describe43.describe44",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/3members.test.js~describe43.describe44.it57",
    "access": null,
    "description": "should change the WebGroup state",
    "lineNumber": 661,
    "testTargets": [
      "WebGroup#onStateChange"
    ]
  },
  {
    "__docId__": 140,
    "kind": "test",
    "name": "it58",
    "testId": 58,
    "memberof": "test/functional/3members.test.js~describe43.describe44",
    "testDepth": 2,
    "static": true,
    "longname": "test/functional/3members.test.js~describe43.describe44.it58",
    "access": null,
    "description": "should change the Signaling state",
    "lineNumber": 677,
    "testTargets": [
      "WebGroup#onSignalingStateChange"
    ]
  }
]