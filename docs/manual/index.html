<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../">
  <title data-ice="title">Manual | Netflux</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<link rel="stylesheet" href="./inject/css/0-style.css"><meta name="description" content="Abstract peer to peer client transport API. Implementations based on WebRTC and webSocket to be done."><meta property="twitter:card" content="summary"><meta property="twitter:title" content="Netflux"><meta property="twitter:description" content="Abstract peer to peer client transport API. Implementations based on WebRTC and webSocket to be done."></head>
<body class="layout-container manual-root manual-index" data-ice="rootContainer">

<header>
  <a href="./" style="display: flex; align-items: center;"><img src="./image/brand_logo.jpg" style="width:34px;"></a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/coast-team/netflux"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div class="manual-toc-root">
  
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/installation.html"><a href="manual/installation.html" data-ice="link">Installation</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/installation.html"><a href="manual/installation.html#npm" data-ice="link">NPM</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/installation.html"><a href="manual/installation.html#what-you-need" data-ice="link">What you need</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/installation.html"><a href="manual/installation.html#signaling-server" data-ice="link">Signaling server</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/installation.html"><a href="manual/installation.html#stun-server" data-ice="link">STUN server</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/installation.html"><a href="manual/installation.html#turn-server" data-ice="link">TURN server</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/installation.html"><a href="manual/installation.html#how-to-deploy-stun-turn-servers" data-ice="link">How to deploy STUN/TURN servers</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/usage.html"><a href="manual/usage.html" data-ice="link">Usage</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/usage.html"><a href="manual/usage.html#commonjs" data-ice="link">CommonJS</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/usage.html"><a href="manual/usage.html#es-module" data-ice="link">ES module</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/usage.html"><a href="manual/usage.html#umd" data-ice="link">UMD</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/usage.html"><a href="manual/usage.html#configuration" data-ice="link">Configuration</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/knownobstacles.html"><a href="manual/knownobstacles.html" data-ice="link">Known WebRTC obstacles</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/knownobstacles.html"><a href="manual/knownobstacles.html#firefox-extensions" data-ice="link">Firefox extensions</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/faq.html"><a href="manual/faq.html" data-ice="link">FAQ</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/faq.html"><a href="manual/faq.html#how-netflux-chooses-between--code-rtcdatachannel--code--and--code-websocket--code-" data-ice="link">How Netflux chooses between RTCDataChannel and WebSocket</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/faq.html"><a href="manual/faq.html#state-description" data-ice="link">State description</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/faq.html"><a href="manual/faq.html#events" data-ice="link">Events</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/faq.html"><a href="manual/faq.html#member-left-event" data-ice="link">Member left event</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/faq.html"><a href="manual/faq.html#signaling-state-event" data-ice="link">Signaling state event</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/faq.html"><a href="manual/faq.html#topology-state-event" data-ice="link">Topology state event</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/faq.html"><a href="manual/faq.html#join-method-call" data-ice="link">Join method call</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/faq.html"><a href="manual/faq.html#leave-method-call" data-ice="link">Leave method call</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/faq.html"><a href="manual/faq.html#online---event--online-offline-events--navigator-online-" data-ice="link">onLine() event (online/offline events, navigator.onLine)</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/faq.html"><a href="manual/faq.html#isvisible---event--page-visibility-api-" data-ice="link">isVisible() event (Page Visibility API)</a></li>
</ul>
  </div>
</div>
</nav>

<div class="content" data-ice="content"><div class="github-markdown">
  

  

  <div class="manual-cards">
    
  <div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Installation</h1><h2>NPM</h2><pre><code class="lang-shell"><code class="source-code prettyprint">npm install netflux</code>
</code></pre><p>3 peer dependencies to be installed for some cases:</p><ul>
<li><code>rxjs</code> is necessary for both NodeJS and browsers if you want to take advantage of EcmaScript modules, tree-shaking etc. Otherwise for it is already included into <code>dist/netflux.browser.es5.umd.js</code> and <code>dist/netflux.node.es5.cjs.js</code> bundles.</li>
</ul><pre><code class="lang-shell"><code class="source-code prettyprint">npm install rxjs</code>
</code></pre><ul>
<li><code>uws</code> and <code>text-encoding</code> if you target NodeJS (developing a bot):</li>
</ul><pre><code class="lang-shell"><code class="source-code prettyprint">npm install uws text-encoding</code>
</code></pre><p>Netflux has an optional dependency: <code>wrtc</code>. This package provides WebRTC API in NodeJS, but for now it is not in use as more tests needed. Checkout <a href="https://github.com/js-platform/node-webrtc">wrtc repository</a> for more info on it.</p><h2>What you need</h2><p>Signaling server is the only mandatory server for Netflux, but for a fully functional peer to peer network which suits all use cases you also need STUN and TURN servers.</p><blockquote>
<p>Netflux comes with Signaling and STUN servers by default for easier quickstart.</p>
</blockquote><h3>Signaling server</h3><blockquote>
<p><strong>Default</strong>: <code>wss://signaling.netflux.coedit.re</code></p>
</blockquote><p>The only signaling mechanism which is supported by Netflux for now is <a href="https://github.com/coast-team/sigver">Sigver</a> (NodeJS WebSocket server developed by us).</p><blockquote>
<p><strong>TIP</strong>: Your own instance of Sigver for production is recommended.</p>
</blockquote><h3>STUN server</h3><p><strong>Default</strong>: <code>stun:stun3.l.google.com:19302</code></p><p>There are many other free STUN servers available in the Web.</p><h3>TURN server</h3><p>There are no free TURN servers available in the Web. Two solutions exist:</p><ul>
<li>Rent one. Checkout <a href="https://xirsys.com/">Xirsys</a> for example.</li>
<li>Deploy your own instance. The paragraphe below provides a guide on how to deploy and configure <a href="https://github.com/coturn/coturn"><code>coturn</code></a> open source TURN server. Also checkout <a href="https://rtcquickstart.org/guide/multi/turn-server-choice.html"><em>Choosing a TURN server</em></a> for a list of open source TURN servers.</li>
</ul><h2>How to deploy STUN/TURN servers</h2><p>This guide present a basic configuration for <a href="https://github.com/coturn/coturn">coturn</a>.
It allow us to deploy our own STUN/TURN server in order to connect users behind a NAT or Firewall.</p><p>For more informations or options, see coturn <a href="https://github.com/coturn/coturn/wiki/README">documentation</a>.</p><p>On most Linux Distribution, the package is in the repo:
<code>apt-get install coturn</code></p><p>You must have SQLite installed:
<code>sudo apt-get install sqlite3 libsqlite3-dev</code></p><p>Config file can be found at:
<code>/etc/turnserver.conf</code></p><p>Simple config file should look like this:</p><pre><code class="lang-bash"><code class="source-code prettyprint"># you can listen ports 3478 and 5349 instead of 80/443
listening-port=80
tls-listening-port=443

listening-ip=YOUR_IP_ADDRESS
relay-ip=YOUR_IP_ADDRESS

realm=YOUR_DOMAIND.COM
server-name=OUR_DOMAIND.COM

fingerprint

# webRTC authentication method
lt-cred-mech

# WebRTC credentials
user=YOUR_USER_NAME:YOUR_PASSWORD

# Quota
total-quota=100
bps-capacity=0
stable-nonce

# Add ssl certificate for your server
cert=/etc/ssl/certificate.pem
pkey=/etc/ssl/private.key
cipher-list=&quot;ECDH+AESGCM:DH+AESGCM:ECDH+AES256:DH+AES256:ECDH+AES128:!DH+AES:!ECDH+3DES:!DH+3DES:!RSA+AES:!RSA+3DES:!ADH:!AECDH:!MD5&quot;
no-loopback-peers
no-multicast-peers
no-stdout-log</code>
</code></pre><p>If you don&apos;t have any SSL certificate, you may use <a href="https://letsencrypt.org/">Let&apos;s Encrypt</a>.</p><p>Launch server:</p><p><code>`</code>turnserver`</p><p>or in daemon:</p><p><code>turnserver -o</code></p><p>Verify that the server is up and running with <a href="https://webrtc.github.io/samples/src/content/peerconnection/trickle-ice/">Trickle ICE</a>.</p></div>
        <a data-ice="link" href="manual/installation.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Usage</h1><p>There are 4 builds (all ES5 code):</p><ul>
<li><code>dist/netflux.cjs.js</code> CommonJS format for NodeJS.</li>
<li><code>dist/esm/netflux.node.js</code> ECMAScript 6 module format for NodeJS.</li>
<li><code>dist/esm/netflux.browser.js</code> ECMAScript 6 module format for browsers.</li>
<li><code>dist/netflux.umd.js</code> UMD format for browsers.</li>
</ul><p>The <code>package.json</code> contains the following fields:</p><pre><code class="lang-json"><code class="source-code prettyprint">...
&quot;main&quot;: &quot;dist/netflux.cjs.js&quot;,
&quot;module&quot;: &quot;dist/esm/index.node.js&quot;,
&quot;browser&quot;: &quot;dist/esm/index.browser.js&quot;,
...</code>
</code></pre><p>All builds are either for NodeJS or for Browser environment.</p><p><strong>For browser environment</strong> exported members are:</p><ul>
<li><code>WebGroup</code> class</li>
<li><code>WebGroupState</code> enum</li>
<li><code>SignalingState</code> enum</li>
<li><code>Topology</code> enum</li>
<li><code>DataType</code> type</li>
<li><code>WebGroupOption</code> type</li>
</ul><p><strong>For NodeJS environment</strong> exported members are the same as for browser plus:</p><ul>
<li><code>Bot</code> class</li>
<li><code>BotOptions</code> type.</li>
</ul><h2>CommonJS</h2><p><code>dist/netflux.cjs.js</code> - CommonJS format, built for NodeJS.</p><pre><code class="lang-Javascript"><code class="source-code prettyprint">// NodeJS
const netflux = require(&apos;netflux&apos;)
var wg = new netflux.WebGroup()</code>
</code></pre><h2>ES module</h2><p><code>esm/index.node.js</code> and <code>esm/index.browser.js</code> are suitable for Webpack, Browserify or any alike, which also undersands <code>package.json#module</code> and <code>package.json#module</code> properties respectively and can parse ES modules.</p><p><code>esm/index.node.js</code> is build for NodeJS: contains all exported API members and all necessary polyfills for NodeJS environment.</p><p><code>esm/index.browser.js</code> is build for browsers.</p><pre><code class="lang-javascript"><code class="source-code prettyprint">export { WebGroup, WebGroupState, Bot, BotOptions } from &apos;netflux&apos;
const wg = new WebGroup()</code>
</code></pre><h2>UMD</h2><p><code>dist/netflux.umd.js</code> - Universal Module Definition format is compatible with AMD, CommonJS and &quot;global&quot; modules. Built for browser and suitable for Webpack, Browserify and any other who also understands <code>package.json#browser</code> property.</p><pre><code class="lang-html"><code class="source-code prettyprint">&lt;!-- Browser global usage example --&gt;
&lt;script src=&quot;netflux.es5.umd.js&quot;&gt;
  window.netflux !== undefined // true
  var wg = new window.netflux.WebGroup()
&lt;/script&gt;</code>
</code></pre><h2>Configuration</h2><p>For a <code>WebGroup</code> object all options are optional.</p><pre><code class="lang-javascript"><code class="source-code prettyprint">// Example:
const wg = new WebGroup({
  signalingServer: &apos;MY_SIGNALING_URL&apos;,
  rtcConfiguration: {
    iceServers: [
      { urls: &apos;stun:mystun.org&apos; },
      {
        urls: [&apos;turn:myturn.org?transport=udp&apos;, &apos;turn:myturn.org?transport=tcp&apos;],
        username: &apos;user&apos;,
        password: &apos;password&apos;,
      },
    ],
  },
})</code>
</code></pre><p>For <code>Bot</code> the server option is mandatory.</p><pre><code class="lang-javascript"><code class="source-code prettyprint">// Example:
const http = require(&apos;http&apos;)
const myServer = http.createServer()
const wg = new Bot({
  server: myServer,
  signalingServer: &apos;MY_SIGNALING_URL&apos;,
  webGroupOptions: {
    rtcConfiguration: {
      iceServers: [
        { urls: &apos;stun:mystun.org&apos; },
        {
          urls: [&apos;turn:myturn.org?transport=udp&apos;, &apos;turn:myturn.org?transport=tcp&apos;],
          username: &apos;user&apos;,
          password: &apos;password&apos;,
        },
      ],
    },
  },
})</code>
</code></pre></div>
        <a data-ice="link" href="manual/usage.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Known WebRTC obstacles</h1><p>Connection establishment over WebRTC may ancounter different obstacles like NAT, Firewall, port blocking. But besides network obstacles there is also browser configuration that may prevent from connection creation.</p><h2>Firefox extensions</h2><p>Some extensions for Firefox (Privacy Badger for instance) modify WebRTC configuration in browser. Checkout <code>about:config</code> and look for <code>peerconnection.ice</code>. If the <em>Status</em> column is <em>default</em> then the parameter was not modified.</p></div>
        <a data-ice="link" href="manual/knownobstacles.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>FAQ</h1><h2>How Netflux chooses between <code>RTCDataChannel</code> and <code>WebSocket</code></h2><p>Netflux operates with <code>RTCDataChannel</code> (WebRTC) and <code>WebSocket</code> connection technologies.</p><p>Technically <code>RTCDataChannel</code> may be established between:</p><ul>
<li>Browser and Browser.</li>
<li>Browser and Server.</li>
<li>Server and Server.</li>
</ul><p>On the other hand, a <code>WebSocket</code> may be created only between:</p><ul>
<li>Browser and Server.</li>
<li>Server and Server.</li>
</ul><p>But in practice:</p><ul>
<li>All modern browsers support <code>WebSocket</code> (Chrome, Firefox, Edge, Safary etc.), but only some of them support <code>RTCDataChannel</code> (Chrome, Firefox, Safari soon and Edge one day maybe).</li>
<li>Servers may or may not listen on <code>WebSocket</code> or connect over <code>WebSocket</code> and may or may not support <code>RTCDataChannel</code>.</li>
</ul><p>This technical diversity pushes us to try all possibilities in order to create a connection between two peers based on their capabilities.</p><p>Between two peers, there is always one who initiates the connection, while the other is in a passive state. Lets say peer _A_ wants to connect to peer _B_ (i.e. _A_ is the initiator).</p><p>The following algorithm is the same for _A_ and _B_ and is executed each time a <code>message</code> is received. It runs through all possiblities in order to establish a connection between these peers (i.e. <code>return SUCCESS</code> if the connection succeed and <code>return FAILED</code> otherwise). It is important that the initiator peer (i.e. A) must be notified about the algorithm&apos;s result, while for the second peer (who is in the passive state) this information has no importance.</p><p><code>message</code> variable below persistes the state of the actions for both peers. It is updated by both and is exchanged between them.</p><pre><code class="lang-pseudocode"><code class="source-code prettyprint">// Pseudocode:
// I received a `message` from another peer

if anotherPeerIsListeningOnWebSocketAndIHaveNotTriedToConnectYet(message)
  if WebSocket connection succeed
    return SUCCESS
  else
    update(message)

if iAmListeningOnWebSocketAndAnotherPeerHasNotTriedToConnectYet(message)
  send(message)
  return

if bothPeersSupportRTCDataChannel(message)
  if iHaveNotTriedToConnectYet(message)
    if RTCDataChannel connection succeed
      return SUCCESS
    else
      update(message)
  if anotherPeerHasNotTriedToConnectYet(message)
    send(message)
    return

if iAmTheInitiator(message)
  return FAILED
else
  send(message)</code>
</code></pre><h2>State description</h2><p>This section describes what trigger the <code>WebChannel</code> (i.e. <code>WebGroup</code>) state to change.</p><p>Possible values for <code>WebChannel</code>, <code>Signaling</code> and <code>Topology</code> states are:</p><table>
<thead>
<tr>
<th>WebChannel</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>JOINING</code></td>
<td>You are about to join the group.</td>
</tr>
<tr>
<td><code>JOINED</code></td>
<td>You have successfully joined the group.</td>
<td></td>
</tr>
<tr>
<td><code>LEFT</code></td>
<td>You have successfully left the group or couldn&apos;t join. This is also the initial value (i.e. after <code>new WebChannel()</code> and before calling <code>join()</code>).</td>
</tr>
</tbody>
</table><table>
<thead>
<tr>
<th>Signaling state</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>CONNECTING</code></td>
<td>The connection with Signaling server is not yet open (equivalent to <code>WebSocket.CONNECTING</code>).</td>
</tr>
<tr>
<td><code>OPEN</code></td>
<td>The connection with Signaling server is open (equivalent to <code>WebSocket.OPEN</code>).</td>
</tr>
<tr>
<td><code>CHECKING</code></td>
<td>Signaling server is about to vefiry that you are connected to at least one group member. If so, then the state becomes <code>CHECKED</code> and nothing to do, otherwise it prompt you to connect to the group member. After that the state becomes <code>CHECKED</code> and the <code>TopologyService</code> should rejoin the group.</td>
</tr>
<tr>
<td><code>CHECKED</code></td>
<td>You are connected to at least one group member or you are the only group member.</td>
<td></td>
</tr>
<tr>
<td><code>CLOSED</code></td>
<td>The connection with Signaling server is closed or couldn&apos;t be opened (equivalent to <code>WebSocket.CLOSED</code>).</td>
</tr>
</tbody>
</table><table>
<thead>
<tr>
<th>Topology state</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>CONSTRUCTING</code></td>
<td>Thanks to the Signaling server you are connected to one of the group member. From now the topology service is about to create the rest of connections, if necessary, in order to keep the topology structure and assure messages delivery.</td>
</tr>
<tr>
<td><code>CONSTRUCTED</code></td>
<td>The topology is considerated as constructed.</td>
</tr>
<tr>
<td><code>IDLE</code></td>
<td>All connections with group members were closed or topology failed to construct the peer to peer network.</td>
</tr>
</tbody>
</table><h3>Events</h3><h4>Member left event</h4><table>
<thead>
<tr>
<th>Singaling</th>
<th>Topology</th>
<th>adjacent member</th>
<th>not only you left in the group</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>CHECKED</td>
<td>CONSTRUCTED</td>
<td>true</td>
<td>true</td>
<td>$signalingCheck</td>
</tr>
</tbody>
</table><h4>Signaling state event</h4><table>
<thead>
<tr>
<th>Singaling</th>
<th>Topology</th>
<th>connected</th>
<th>rejoinEnabled</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>CLOSED</td>
<td>IDLE</td>
<td></td>
<td>true</td>
<td>$rejoin</td>
</tr>
<tr>
<td>CLOSED</td>
<td>IDLE</td>
<td></td>
<td>false</td>
<td>$leave</td>
</tr>
<tr>
<td>CLOSED</td>
<td>CONSTRUCTED</td>
<td></td>
<td>true</td>
<td>$connectToSignaling</td>
</tr>
<tr>
<td>OPEN</td>
<td>!CONSTRUCTING</td>
<td></td>
<td></td>
<td>$signalingCheck</td>
</tr>
<tr>
<td>CHECKED</td>
<td>IDLE</td>
<td>true</td>
<td></td>
<td>Topology.CONSTRUCTED</td>
</tr>
<tr>
<td>CHECKED</td>
<td>CONSTRUCTED</td>
<td></td>
<td></td>
<td>WebChannel.JOINED</td>
</tr>
</tbody>
</table><h4>Topology state event</h4><table>
<thead>
<tr>
<th>Topology</th>
<th>Singaling</th>
<th>rejoinEnabled</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>CONSTRUCTING</td>
<td></td>
<td></td>
<td>WebChannel.JOINING</td>
</tr>
<tr>
<td>CONSTRUCTED</td>
<td>OPEN</td>
<td></td>
<td>$signalingCheck</td>
</tr>
<tr>
<td>CONSTRUCTED</td>
<td>CHECKED</td>
<td></td>
<td>WebChannel.JOINED &amp; $signalingCheck</td>
</tr>
<tr>
<td>CONSTRUCTED</td>
<td>CLOSED</td>
<td></td>
<td>$connectToSignaling</td>
</tr>
<tr>
<td>IDLE</td>
<td>CLOSED</td>
<td>true</td>
<td>$rejoin</td>
</tr>
<tr>
<td>IDLE</td>
<td>CLOSED</td>
<td>false</td>
<td>$leave</td>
</tr>
<tr>
<td>IDLE</td>
<td>CONNECTING</td>
<td></td>
<td>WebChannel.JOINING</td>
</tr>
<tr>
<td>IDLE</td>
<td>OPEN</td>
<td></td>
<td>WebChannel.JOINING &amp; $signalingCheck</td>
</tr>
<tr>
<td>IDLE</td>
<td>CHECKING</td>
<td></td>
<td>WebChannel.JOINING</td>
</tr>
<tr>
<td>IDLE</td>
<td>CHECKED</td>
<td></td>
<td>$signalingCheck</td>
</tr>
</tbody>
</table><h4>Join method call</h4><table>
<thead>
<tr>
<th>WebChannel</th>
<th>onLine</th>
<th>Visibility</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>LEFT</td>
<td>true</td>
<td>visible</td>
<td>$join</td>
</tr>
</tbody>
</table><h4>Leave method call</h4><table>
<thead>
<tr>
<th>WebChannel</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>!LEFT</td>
<td>$leave</td>
</tr>
</tbody>
</table><h4>onLine() event (online/offline events, navigator.onLine)</h4><table>
<thead>
<tr>
<th>WebChannel</th>
<th>Visibility</th>
<th>rejoinEnabled</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>LEFT</td>
<td>visible</td>
<td>true</td>
<td>$leave.1 &amp; $join</td>
</tr>
</tbody>
</table><h4>isVisible() event (Page Visibility API)</h4><table>
<thead>
<tr>
<th>WebChannel</th>
<th>onLine</th>
<th>rejoinEnabled</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td>LEFT</td>
<td>true</td>
<td>true</td>
<td>$leave.1 &amp; $join</td>
</tr>
</tbody>
</table><blockquote>
<p>$join -&gt; consists of three steps:</p>
</blockquote><ol>
<li>Initialize WebChannel properties (ids, members etc.), then</li>
<li>Set WebChannel state to JOINING and finally</li>
<li>Connect to Signaling server</li>
</ol><blockquote>
<p>$leave -&gt; consists of two steps</p>
</blockquote><ol>
<li>Clean WebChannel properties (ids, members, clean servicies) as if we were doing <code>new WebChannel()</code>, then</li>
<li>Set WebChannel state to LEFT</li>
</ol><blockquote>
<p>$rejoin -&gt; consists of executing the following algorithm:</p>
</blockquote><pre><code class="lang-pseudocode"><code class="source-code prettyprint">  Execute $leave.1
    Execute $join.1
    Execute $join.2
    setTimeout
      if (WebChannel.LEFT &amp;&amp; visible &amp;&amp; onLine &amp;&amp; rejoinEnabled) then
        $connectToSignaling</code>
</code></pre><blockquote>
<p>$connectToSignaling -&gt; the third step of the $join process</p>
<p>$signalingCheck -&gt; check with Signaling if still connected with the rest of the group</p>
</blockquote></div>
        <a data-ice="link" href="manual/faq.html"></a>
      </div>
    </div>
</div>
</div>
</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
